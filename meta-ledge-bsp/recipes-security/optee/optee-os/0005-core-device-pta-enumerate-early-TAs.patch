From 5f33ea52cc44258d0004ea8fde41c42b22a8a5da Mon Sep 17 00:00:00 2001
From: Maxim Uvarov <maxim.uvarov@linaro.org>
Date: Wed, 1 Apr 2020 08:08:06 +0100
Subject: [PATCH 5/6] core: device pta: enumerate early TAs

This is an extension of commit 0b611081804a ("core: pta: Add device
pseudo TA") to register not only pseudo-TAs but also user-space early
TAs that have TA_FLAG_DEVICE_ENUM set.

This change makes early TAs visible on optee bus in the Linux kernel.

Signed-off-by: Maxim Uvarov <maxim.uvarov@linaro.org>
Reviewed-by: Jerome Forissier <jerome@forissier.org>
Signed-off-by: Maxim Uvarov <maxim.uvarov@linaro.org>
---
 core/arch/arm/pta/device.c | 56 ++++++++++++++++++++++----------------
 1 file changed, 33 insertions(+), 23 deletions(-)

diff --git a/core/arch/arm/pta/device.c b/core/arch/arm/pta/device.c
index 9011e989..ae74f898 100644
--- a/core/arch/arm/pta/device.c
+++ b/core/arch/arm/pta/device.c
@@ -8,6 +8,9 @@
  * UUIDs which can act as TEE bus devices.
  */
 
+#include <config.h>
+#include <kernel/linker.h>
+#include <kernel/early_ta.h>
 #include <kernel/pseudo_ta.h>
 #include <kernel/tee_ta_manager.h>
 #include <pta_device.h>
@@ -17,14 +20,24 @@
 
 #define PTA_NAME "device.pta"
 
+static void add_ta(uint32_t flags, const TEE_UUID *uuid, uint8_t *buf,
+		   uint32_t blen, uint32_t *pos)
+{
+	if (flags & TA_FLAG_DEVICE_ENUM) {
+		if (*pos + sizeof(*uuid) <= blen)
+			tee_uuid_to_octets(buf + *pos, uuid);
+
+		(*pos) += sizeof(*uuid);
+	}
+}
+
 static TEE_Result get_devices(uint32_t types,
 			      TEE_Param params[TEE_NUM_PARAMS])
 {
-	const struct pseudo_ta_head *ta;
-	TEE_UUID *device_uuid = NULL;
-	uint8_t uuid_octet[sizeof(TEE_UUID)];
-	size_t ip_size, op_size = 0;
-	TEE_Result res = TEE_SUCCESS;
+	const struct pseudo_ta_head *ta = NULL;
+	void *buf = NULL;
+	uint32_t blen = 0;
+	uint32_t pos = 0;
 
 	if (types != TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_OUTPUT,
 				     TEE_PARAM_TYPE_NONE,
@@ -35,27 +48,24 @@ static TEE_Result get_devices(uint32_t types,
 	if (!params[0].memref.buffer && (params[0].memref.size > 0))
 		return TEE_ERROR_BAD_PARAMETERS;
 
-	device_uuid = (TEE_UUID *)params[0].memref.buffer;
-	ip_size = params[0].memref.size;
-
-	SCATTERED_ARRAY_FOREACH(ta, pseudo_tas, struct pseudo_ta_head) {
-		if (ta->flags & TA_FLAG_DEVICE_ENUM) {
-			if (ip_size < sizeof(TEE_UUID)) {
-				res = TEE_ERROR_SHORT_BUFFER;
-			} else {
-				tee_uuid_to_octets(uuid_octet, &ta->uuid);
-				memcpy(device_uuid, uuid_octet,
-				       sizeof(TEE_UUID));
-				device_uuid++;
-				ip_size -= sizeof(TEE_UUID);
-			}
-			op_size += sizeof(TEE_UUID);
-		}
+	buf =  params[0].memref.buffer;
+	blen = params[0].memref.size;
+
+	SCATTERED_ARRAY_FOREACH(ta, pseudo_tas, struct pseudo_ta_head)
+		add_ta(ta->flags, &ta->uuid, buf, blen, &pos);
+
+	if (IS_ENABLED(CFG_EARLY_TA)) {
+		const struct early_ta *eta = NULL;
+
+		for_each_early_ta(eta)
+			add_ta(eta->flags, &eta->uuid, buf, blen, &pos);
 	}
 
-	params[0].memref.size = op_size;
+	params[0].memref.size = pos;
+	if (pos > blen)
+		return TEE_ERROR_SHORT_BUFFER;
 
-	return res;
+	return TEE_SUCCESS;
 }
 
 static TEE_Result invoke_command(void *pSessionContext __unused,
-- 
2.17.1


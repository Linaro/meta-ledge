From 322eb76a8c39bc8c2e255fc863a08a6734c6453c Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@linaro.org>
Date: Tue, 2 Jul 2019 13:26:00 +0200
Subject: [PATCH] STM32mp157 upstream for 2019.10

Signed-off-by: Christophe Priouzeau <christophe.priouzeau@linaro.org>
---
 arch/arm/Kconfig                              |   1 +
 arch/arm/dts/Makefile                         |   1 -
 arch/arm/dts/stm32mp15-ddr.dtsi               |   2 +-
 arch/arm/dts/stm32mp157-pinctrl.dtsi          | 276 ++++++++++++++-
 arch/arm/dts/stm32mp157-u-boot.dtsi           |  68 ++--
 arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi      |   3 -
 arch/arm/dts/stm32mp157a-dk1.dts              |  30 +-
 arch/arm/dts/stm32mp157c-dk2.dts              |   1 +
 arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi      |  15 +-
 arch/arm/dts/stm32mp157c-ed1.dts              | 205 +++--------
 arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi      |   3 -
 arch/arm/dts/stm32mp157c-ev1.dts              |  12 +-
 arch/arm/dts/stm32mp157c.dtsi                 | 215 +++++++++---
 arch/arm/mach-stm32mp/Kconfig                 |  25 ++
 arch/arm/mach-stm32mp/Makefile                |   2 +
 arch/arm/mach-stm32mp/cmd_stm32key.c          | 101 ++++++
 arch/arm/mach-stm32mp/cpu.c                   |   7 +-
 arch/arm/mach-stm32mp/fdt.c                   | 223 ++++++++++++
 arch/arm/mach-stm32mp/include/mach/stm32.h    |   3 +-
 .../arm/mach-stm32mp/include/mach/sys_proto.h |   9 +
 arch/arm/mach-stm32mp/syscon.c                |   2 -
 board/st/stm32mp1/Kconfig                     |   7 +
 board/st/stm32mp1/MAINTAINERS                 |   1 +
 board/st/stm32mp1/Makefile                    |   1 +
 board/st/stm32mp1/README                      |  43 ++-
 board/st/stm32mp1/cmd_stboard.c               | 145 ++++++++
 board/st/stm32mp1/spl.c                       |   1 -
 board/st/stm32mp1/stm32mp1.c                  |   8 +-
 configs/stm32mp15_basic_defconfig             |   5 +-
 configs/stm32mp15_optee_defconfig             |  73 ++++
 configs/stm32mp15_trusted_defconfig           |   4 +-
 .../pinctrl/st,stm32-pinctrl.txt              | 101 +++++-
 drivers/clk/clk_stm32mp1.c                    |  12 +-
 drivers/rtc/Kconfig                           |   6 +
 drivers/rtc/Makefile                          |   1 +
 drivers/rtc/stm32_rtc.c                       | 321 ++++++++++++++++++
 include/configs/stm32mp1.h                    |   6 +-
 include/dt-bindings/pinctrl/stm32-pinfunc.h   |   6 +
 38 files changed, 1618 insertions(+), 327 deletions(-)
 create mode 100644 arch/arm/mach-stm32mp/cmd_stm32key.c
 create mode 100644 arch/arm/mach-stm32mp/fdt.c
 create mode 100644 board/st/stm32mp1/cmd_stboard.c
 create mode 100644 configs/stm32mp15_optee_defconfig
 create mode 100644 drivers/rtc/stm32_rtc.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index f5a7630e4f..6f9c2010ba 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1488,6 +1488,7 @@ config ARCH_STM32MP
 	select MISC
 	select OF_CONTROL
 	select OF_LIBFDT
+	select OF_SYSTEM_SETUP
 	select PINCTRL
 	select REGMAP
 	select SUPPORT_SPL
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 7fbd0a1d06..d37882f094 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -760,7 +760,6 @@ dtb-$(CONFIG_ARCH_STI) += stih410-b2260.dtb
 
 dtb-$(CONFIG_TARGET_STM32MP1) += \
 	stm32mp157a-dk1.dtb \
-	stm32mp157a-avenger96.dtb \
 	stm32mp157c-dk2.dtb \
 	stm32mp157c-ed1.dtb \
 	stm32mp157c-ev1.dtb
diff --git a/arch/arm/dts/stm32mp15-ddr.dtsi b/arch/arm/dts/stm32mp15-ddr.dtsi
index 4172c02f0a..0164e34216 100644
--- a/arch/arm/dts/stm32mp15-ddr.dtsi
+++ b/arch/arm/dts/stm32mp15-ddr.dtsi
@@ -5,7 +5,7 @@
 
 / {
 	soc {
-		ddr: ddr@0x5A003000{
+		ddr: ddr@5A003000{
 			u-boot,dm-pre-reloc;
 
 			compatible = "st,stm32mp1-ddr";
diff --git a/arch/arm/dts/stm32mp157-pinctrl.dtsi b/arch/arm/dts/stm32mp157-pinctrl.dtsi
index 4c424c488d..38f4a1afe9 100644
--- a/arch/arm/dts/stm32mp157-pinctrl.dtsi
+++ b/arch/arm/dts/stm32mp157-pinctrl.dtsi
@@ -14,6 +14,7 @@
 			ranges = <0 0x50002000 0xa400>;
 			interrupt-parent = <&exti>;
 			st,syscfg = <&exti 0x60 0xff>;
+			hwlocks = <&hwspinlock 0>;
 			pins-are-numbered;
 
 			gpioa: gpio@50002000 {
@@ -164,6 +165,27 @@
 				};
 			};
 
+			cec_pins_sleep_a: cec-sleep-0 {
+				pins {
+					pinmux = <STM32_PINMUX('A', 15, ANALOG)>; /* HDMI_CEC */
+				};
+			};
+
+			cec_pins_b: cec-1 {
+				pins {
+					pinmux = <STM32_PINMUX('B', 6, AF5)>;
+					bias-disable;
+					drive-open-drain;
+					slew-rate = <0>;
+				};
+			};
+
+			cec_pins_sleep_b: cec-sleep-1 {
+				pins {
+					pinmux = <STM32_PINMUX('B', 6, ANALOG)>; /* HDMI_CEC */
+				};
+			};
+
 			ethernet0_rgmii_pins_a: rgmii-0 {
 				pins1 {
 					pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
@@ -269,7 +291,14 @@
 				};
 			};
 
-			i2c1_pins_b: i2c1-1 {
+			i2c1_pins_sleep_a: i2c1-1 {
+				pins {
+					pinmux = <STM32_PINMUX('D', 12, ANALOG)>, /* I2C1_SCL */
+						 <STM32_PINMUX('F', 15, ANALOG)>; /* I2C1_SDA */
+				};
+			};
+
+			i2c1_pins_b: i2c1-2 {
 				pins {
 					pinmux = <STM32_PINMUX('F', 14, AF5)>, /* I2C1_SCL */
 						 <STM32_PINMUX('F', 15, AF5)>; /* I2C1_SDA */
@@ -289,7 +318,14 @@
 				};
 			};
 
-			i2c2_pins_b: i2c2-1 {
+			i2c2_pins_sleep_a: i2c2-1 {
+				pins {
+					pinmux = <STM32_PINMUX('H', 4, ANALOG)>, /* I2C2_SCL */
+						 <STM32_PINMUX('H', 5, ANALOG)>; /* I2C2_SDA */
+				};
+			};
+
+			i2c2_pins_b: i2c2-2 {
 				pins {
 					pinmux = <STM32_PINMUX('Z', 0, AF3)>, /* I2C2_SCL */
 						 <STM32_PINMUX('H', 5, AF4)>; /* I2C2_SDA */
@@ -309,6 +345,152 @@
 				};
 			};
 
+			i2c5_pins_sleep_a: i2c5-1 {
+				pins {
+					pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* I2C5_SCL */
+						 <STM32_PINMUX('A', 12, ANALOG)>; /* I2C5_SDA */
+
+				};
+			};
+
+			ltdc_pins_a: ltdc-a-0 {
+				pins {
+					pinmux = <STM32_PINMUX('G',  7, AF14)>, /* LCD_CLK */
+						 <STM32_PINMUX('I', 10, AF14)>, /* LCD_HSYNC */
+						 <STM32_PINMUX('I',  9, AF14)>, /* LCD_VSYNC */
+						 <STM32_PINMUX('F', 10, AF14)>, /* LCD_DE */
+						 <STM32_PINMUX('H',  2, AF14)>, /* LCD_R0 */
+						 <STM32_PINMUX('H',  3, AF14)>, /* LCD_R1 */
+						 <STM32_PINMUX('H',  8, AF14)>, /* LCD_R2 */
+						 <STM32_PINMUX('H',  9, AF14)>, /* LCD_R3 */
+						 <STM32_PINMUX('H', 10, AF14)>, /* LCD_R4 */
+						 <STM32_PINMUX('C',  0, AF14)>, /* LCD_R5 */
+						 <STM32_PINMUX('H', 12, AF14)>, /* LCD_R6 */
+						 <STM32_PINMUX('E', 15, AF14)>, /* LCD_R7 */
+						 <STM32_PINMUX('E',  5, AF14)>, /* LCD_G0 */
+						 <STM32_PINMUX('E',  6, AF14)>, /* LCD_G1 */
+						 <STM32_PINMUX('H', 13, AF14)>, /* LCD_G2 */
+						 <STM32_PINMUX('H', 14, AF14)>, /* LCD_G3 */
+						 <STM32_PINMUX('H', 15, AF14)>, /* LCD_G4 */
+						 <STM32_PINMUX('I',  0, AF14)>, /* LCD_G5 */
+						 <STM32_PINMUX('I',  1, AF14)>, /* LCD_G6 */
+						 <STM32_PINMUX('I',  2, AF14)>, /* LCD_G7 */
+						 <STM32_PINMUX('D',  9, AF14)>, /* LCD_B0 */
+						 <STM32_PINMUX('G', 12, AF14)>, /* LCD_B1 */
+						 <STM32_PINMUX('G', 10, AF14)>, /* LCD_B2 */
+						 <STM32_PINMUX('D', 10, AF14)>, /* LCD_B3 */
+						 <STM32_PINMUX('I',  4, AF14)>, /* LCD_B4 */
+						 <STM32_PINMUX('A',  3, AF14)>, /* LCD_B5 */
+						 <STM32_PINMUX('B',  8, AF14)>, /* LCD_B6 */
+						 <STM32_PINMUX('D',  8, AF14)>; /* LCD_B7 */
+					bias-disable;
+					drive-push-pull;
+					slew-rate = <1>;
+				};
+			};
+
+			ltdc_pins_sleep_a: ltdc-a-1 {
+				pins {
+					pinmux = <STM32_PINMUX('G',  7, ANALOG)>, /* LCD_CLK */
+						 <STM32_PINMUX('I', 10, ANALOG)>, /* LCD_HSYNC */
+						 <STM32_PINMUX('I',  9, ANALOG)>, /* LCD_VSYNC */
+						 <STM32_PINMUX('F', 10, ANALOG)>, /* LCD_DE */
+						 <STM32_PINMUX('H',  2, ANALOG)>, /* LCD_R0 */
+						 <STM32_PINMUX('H',  3, ANALOG)>, /* LCD_R1 */
+						 <STM32_PINMUX('H',  8, ANALOG)>, /* LCD_R2 */
+						 <STM32_PINMUX('H',  9, ANALOG)>, /* LCD_R3 */
+						 <STM32_PINMUX('H', 10, ANALOG)>, /* LCD_R4 */
+						 <STM32_PINMUX('C',  0, ANALOG)>, /* LCD_R5 */
+						 <STM32_PINMUX('H', 12, ANALOG)>, /* LCD_R6 */
+						 <STM32_PINMUX('E', 15, ANALOG)>, /* LCD_R7 */
+						 <STM32_PINMUX('E',  5, ANALOG)>, /* LCD_G0 */
+						 <STM32_PINMUX('E',  6, ANALOG)>, /* LCD_G1 */
+						 <STM32_PINMUX('H', 13, ANALOG)>, /* LCD_G2 */
+						 <STM32_PINMUX('H', 14, ANALOG)>, /* LCD_G3 */
+						 <STM32_PINMUX('H', 15, ANALOG)>, /* LCD_G4 */
+						 <STM32_PINMUX('I',  0, ANALOG)>, /* LCD_G5 */
+						 <STM32_PINMUX('I',  1, ANALOG)>, /* LCD_G6 */
+						 <STM32_PINMUX('I',  2, ANALOG)>, /* LCD_G7 */
+						 <STM32_PINMUX('D',  9, ANALOG)>, /* LCD_B0 */
+						 <STM32_PINMUX('G', 12, ANALOG)>, /* LCD_B1 */
+						 <STM32_PINMUX('G', 10, ANALOG)>, /* LCD_B2 */
+						 <STM32_PINMUX('D', 10, ANALOG)>, /* LCD_B3 */
+						 <STM32_PINMUX('I',  4, ANALOG)>, /* LCD_B4 */
+						 <STM32_PINMUX('A',  3, ANALOG)>, /* LCD_B5 */
+						 <STM32_PINMUX('B',  8, ANALOG)>, /* LCD_B6 */
+						 <STM32_PINMUX('D',  8, ANALOG)>; /* LCD_B7 */
+				};
+			};
+
+			ltdc_pins_b: ltdc-b-0 {
+				pins {
+					pinmux = <STM32_PINMUX('I', 14, AF14)>, /* LCD_CLK */
+						 <STM32_PINMUX('I', 12, AF14)>, /* LCD_HSYNC */
+						 <STM32_PINMUX('I', 13, AF14)>, /* LCD_VSYNC */
+						 <STM32_PINMUX('K',  7, AF14)>, /* LCD_DE */
+						 <STM32_PINMUX('I', 15, AF14)>, /* LCD_R0 */
+						 <STM32_PINMUX('J',  0, AF14)>, /* LCD_R1 */
+						 <STM32_PINMUX('J',  1, AF14)>, /* LCD_R2 */
+						 <STM32_PINMUX('J',  2, AF14)>, /* LCD_R3 */
+						 <STM32_PINMUX('J',  3, AF14)>, /* LCD_R4 */
+						 <STM32_PINMUX('J',  4, AF14)>, /* LCD_R5 */
+						 <STM32_PINMUX('J',  5, AF14)>, /* LCD_R6 */
+						 <STM32_PINMUX('J',  6, AF14)>, /* LCD_R7 */
+						 <STM32_PINMUX('J',  7, AF14)>, /* LCD_G0 */
+						 <STM32_PINMUX('J',  8, AF14)>, /* LCD_G1 */
+						 <STM32_PINMUX('J',  9, AF14)>, /* LCD_G2 */
+						 <STM32_PINMUX('J', 10, AF14)>, /* LCD_G3 */
+						 <STM32_PINMUX('J', 11, AF14)>, /* LCD_G4 */
+						 <STM32_PINMUX('K',  0, AF14)>, /* LCD_G5 */
+						 <STM32_PINMUX('K',  1, AF14)>, /* LCD_G6 */
+						 <STM32_PINMUX('K',  2, AF14)>, /* LCD_G7 */
+						 <STM32_PINMUX('J', 12, AF14)>, /* LCD_B0 */
+						 <STM32_PINMUX('J', 13, AF14)>, /* LCD_B1 */
+						 <STM32_PINMUX('J', 14, AF14)>, /* LCD_B2 */
+						 <STM32_PINMUX('J', 15, AF14)>, /* LCD_B3 */
+						 <STM32_PINMUX('K',  3, AF14)>, /* LCD_B4 */
+						 <STM32_PINMUX('K',  4, AF14)>, /* LCD_B5 */
+						 <STM32_PINMUX('K',  5, AF14)>, /* LCD_B6 */
+						 <STM32_PINMUX('K',  6, AF14)>; /* LCD_B7 */
+					bias-disable;
+					drive-push-pull;
+					slew-rate = <1>;
+				};
+			};
+
+			ltdc_pins_sleep_b: ltdc-b-1 {
+				pins {
+					pinmux = <STM32_PINMUX('I', 14, ANALOG)>, /* LCD_CLK */
+						 <STM32_PINMUX('I', 12, ANALOG)>, /* LCD_HSYNC */
+						 <STM32_PINMUX('I', 13, ANALOG)>, /* LCD_VSYNC */
+						 <STM32_PINMUX('K',  7, ANALOG)>, /* LCD_DE */
+						 <STM32_PINMUX('I', 15, ANALOG)>, /* LCD_R0 */
+						 <STM32_PINMUX('J',  0, ANALOG)>, /* LCD_R1 */
+						 <STM32_PINMUX('J',  1, ANALOG)>, /* LCD_R2 */
+						 <STM32_PINMUX('J',  2, ANALOG)>, /* LCD_R3 */
+						 <STM32_PINMUX('J',  3, ANALOG)>, /* LCD_R4 */
+						 <STM32_PINMUX('J',  4, ANALOG)>, /* LCD_R5 */
+						 <STM32_PINMUX('J',  5, ANALOG)>, /* LCD_R6 */
+						 <STM32_PINMUX('J',  6, ANALOG)>, /* LCD_R7 */
+						 <STM32_PINMUX('J',  7, ANALOG)>, /* LCD_G0 */
+						 <STM32_PINMUX('J',  8, ANALOG)>, /* LCD_G1 */
+						 <STM32_PINMUX('J',  9, ANALOG)>, /* LCD_G2 */
+						 <STM32_PINMUX('J', 10, ANALOG)>, /* LCD_G3 */
+						 <STM32_PINMUX('J', 11, ANALOG)>, /* LCD_G4 */
+						 <STM32_PINMUX('K',  0, ANALOG)>, /* LCD_G5 */
+						 <STM32_PINMUX('K',  1, ANALOG)>, /* LCD_G6 */
+						 <STM32_PINMUX('K',  2, ANALOG)>, /* LCD_G7 */
+						 <STM32_PINMUX('J', 12, ANALOG)>, /* LCD_B0 */
+						 <STM32_PINMUX('J', 13, ANALOG)>, /* LCD_B1 */
+						 <STM32_PINMUX('J', 14, ANALOG)>, /* LCD_B2 */
+						 <STM32_PINMUX('J', 15, ANALOG)>, /* LCD_B3 */
+						 <STM32_PINMUX('K',  3, ANALOG)>, /* LCD_B4 */
+						 <STM32_PINMUX('K',  4, ANALOG)>, /* LCD_B5 */
+						 <STM32_PINMUX('K',  5, ANALOG)>, /* LCD_B6 */
+						 <STM32_PINMUX('K',  6, ANALOG)>; /* LCD_B7 */
+				};
+			};
+
 			m_can1_pins_a: m-can1-0 {
 				pins1 {
 					pinmux = <STM32_PINMUX('H', 13, AF9)>; /* CAN1_TX */
@@ -322,6 +504,13 @@
 				};
 			};
 
+			m_can1_sleep_pins_a: m_can1-sleep@0 {
+				pins {
+					pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
+						 <STM32_PINMUX('I', 9, ANALOG)>; /* CAN1_RX */
+				};
+			};
+
 			pwm2_pins_a: pwm2-0 {
 				pins {
 					pinmux = <STM32_PINMUX('A', 3, AF1)>; /* TIM2_CH4 */
@@ -393,32 +582,76 @@
 					slew-rate = <3>;
 				};
 			};
-			sdmmc1_b4_pins_a: sdmmc1-b4@0 {
-				pins {
+
+			sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
+				pins1 {
 					pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
 						 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
 						 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
 						 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
-						 <STM32_PINMUX('C', 12, AF12)>, /* SDMMC1_CK */
-						 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+						 <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
 					slew-rate = <3>;
 					drive-push-pull;
 					bias-disable;
 				};
+				pins2{
+					pinmux = <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+					slew-rate = <3>;
+					drive-open-drain;
+					bias-disable;
+				};
 			};
 
-			sdmmc1_dir_pins_a: sdmmc1-dir@0 {
+			sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
 				pins {
+					pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
+						 <STM32_PINMUX('C', 9, ANALOG)>, /* SDMMC1_D1 */
+						 <STM32_PINMUX('C', 10, ANALOG)>, /* SDMMC1_D2 */
+						 <STM32_PINMUX('C', 11, ANALOG)>, /* SDMMC1_D3 */
+						 <STM32_PINMUX('C', 12, ANALOG)>, /* SDMMC1_CK */
+						 <STM32_PINMUX('D', 2, ANALOG)>; /* SDMMC1_CMD */
+				};
+			};
+
+			sdmmc1_dir_pins_a: sdmmc1-dir-0 {
+				pins1 {
 					pinmux = <STM32_PINMUX('F', 2, AF11)>, /* SDMMC1_D0DIR */
 						 <STM32_PINMUX('C', 7, AF8)>, /* SDMMC1_D123DIR */
-						 <STM32_PINMUX('B', 9, AF11)>, /* SDMMC1_CDIR */
-						 <STM32_PINMUX('E', 4, AF8)>; /* SDMMC1_CKIN */
+						 <STM32_PINMUX('B', 9, AF11)>; /* SDMMC1_CDIR */
 					slew-rate = <3>;
 					drive-push-pull;
 					bias-pull-up;
 				};
+				pins2{
+					pinmux = <STM32_PINMUX('E', 4, AF8)>; /* SDMMC1_CKIN */
+					bias-pull-up;
+				};
+			};
+
+			sdmmc1_dir_sleep_pins_a: sdmmc1-dir-sleep-0 {
+				pins {
+					pinmux = <STM32_PINMUX('F', 2, ANALOG)>, /* SDMMC1_D0DIR */
+						 <STM32_PINMUX('C', 7, ANALOG)>, /* SDMMC1_D123DIR */
+						 <STM32_PINMUX('B', 9, ANALOG)>, /* SDMMC1_CDIR */
+						 <STM32_PINMUX('E', 4, ANALOG)>; /* SDMMC1_CKIN */
+				};
+			};
+
+			sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+				pins {
+					pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+						 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+						 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+						 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+						 <STM32_PINMUX('C', 12, AF12)>, /* SDMMC1_CK */
+						 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
+					slew-rate = <3>;
+					drive-push-pull;
+					bias-disable;
+				};
 			};
-			sdmmc2_b4_pins_a: sdmmc2-b4@0 {
+
+			sdmmc2_b4_pins_a: sdmmc2-b4-0 {
 				pins {
 					pinmux = <STM32_PINMUX('B', 14, AF9)>, /* SDMMC2_D0 */
 						 <STM32_PINMUX('B', 15, AF9)>, /* SDMMC2_D1 */
@@ -432,7 +665,7 @@
 				};
 			};
 
-			sdmmc2_d47_pins_a: sdmmc2-d47@0 {
+			sdmmc2_d47_pins_a: sdmmc2-d47-0 {
 				pins {
 					pinmux = <STM32_PINMUX('A', 8, AF9)>, /* SDMMC2_D4 */
 						 <STM32_PINMUX('A', 9, AF10)>, /* SDMMC2_D5 */
@@ -444,6 +677,19 @@
 				};
 			};
 
+			spdifrx_pins_a: spdifrx-0 {
+				pins {
+					pinmux = <STM32_PINMUX('G', 12, AF8)>; /* SPDIF_IN1 */
+					bias-disable;
+				};
+			};
+
+			spdifrx_sleep_pins_a: spdifrx-1 {
+				pins {
+					pinmux = <STM32_PINMUX('G', 12, ANALOG)>; /* SPDIF_IN1 */
+				};
+			};
+
 			spi2_pins_a: spi2-0 {
 				pins1 {
 					pinmux = <STM32_PINMUX('B', 10, AF5)>, /* SPI2_SCK */
@@ -522,6 +768,7 @@
 			pins-are-numbered;
 			interrupt-parent = <&exti>;
 			st,syscfg = <&exti 0x60 0xff>;
+			hwlocks = <&hwspinlock 0>;
 
 			gpioz: gpio@54004000 {
 				gpio-controller;
@@ -546,6 +793,13 @@
 				};
 			};
 
+			i2c4_pins_sleep_a: i2c4-1 {
+				pins {
+					pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I2C4_SCL */
+						 <STM32_PINMUX('Z', 5, ANALOG)>; /* I2C4_SDA */
+				};
+			};
+
 			spi1_pins_a: spi1-0 {
 				pins1 {
 					pinmux = <STM32_PINMUX('Z', 0, AF5)>, /* SPI1_SCK */
diff --git a/arch/arm/dts/stm32mp157-u-boot.dtsi b/arch/arm/dts/stm32mp157-u-boot.dtsi
index 09560e2d91..eac884c2fa 100644
--- a/arch/arm/dts/stm32mp157-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157-u-boot.dtsi
@@ -21,63 +21,40 @@
 		pinctrl1 = &pinctrl_z;
 	};
 
-	config {
+	clocks {
 		u-boot,dm-pre-reloc;
 	};
 
-	clocks {
+	reboot {
 		u-boot,dm-pre-reloc;
 	};
 
 	soc {
 		u-boot,dm-pre-reloc;
-
-		stgen: stgen@5C008000 {
-			compatible = "st,stm32-stgen";
-			reg = <0x5C008000 0x1000>;
-			status = "okay";
-			u-boot,dm-pre-reloc;
-		};
 	};
 };
 
 &bsec {
-	u-boot,dm-pre-reloc;
-};
-
-&clk_hsi {
-	u-boot,dm-pre-reloc;
-};
-
-&clk_hse {
-	u-boot,dm-pre-reloc;
-};
-
-&clk_lse {
-	u-boot,dm-pre-reloc;
-};
-
-&clk_lsi {
-	u-boot,dm-pre-reloc;
+	u-boot,dm-pre-proper;
 };
 
 &clk_csi {
 	u-boot,dm-pre-reloc;
 };
 
-&rcc {
+&clk_hsi {
 	u-boot,dm-pre-reloc;
 };
 
-&rcc_reboot {
+&clk_hse {
 	u-boot,dm-pre-reloc;
 };
 
-&pinctrl {
+&clk_lsi {
 	u-boot,dm-pre-reloc;
 };
 
-&pinctrl_z {
+&clk_lse {
 	u-boot,dm-pre-reloc;
 };
 
@@ -141,6 +118,35 @@
 	u-boot,dm-pre-reloc;
 };
 
-&iwdg2 {
+&pinctrl {
+	u-boot,dm-pre-reloc;
+};
+
+&pinctrl_z {
+	u-boot,dm-pre-reloc;
+};
+
+&pwr {
+	u-boot,dm-pre-reloc;
+};
+
+&rcc {
 	u-boot,dm-pre-reloc;
 };
+
+&sdmmc1 {
+	compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+};
+
+&sdmmc2 {
+	compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+};
+
+&sdmmc3 {
+	compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+};
+
+&usbotg_hs {
+	compatible = "st,stm32mp1-hsotg", "snps,dwc2";
+};
+
diff --git a/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi b/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
index 0f32a38dc9..ac1640f292 100644
--- a/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
@@ -195,6 +195,3 @@
 	hnp-srp-disable;
 };
 
-&v3v3 {
-	regulator-always-on;
-};
diff --git a/arch/arm/dts/stm32mp157a-dk1.dts b/arch/arm/dts/stm32mp157a-dk1.dts
index e36773dde9..3925be2751 100644
--- a/arch/arm/dts/stm32mp157a-dk1.dts
+++ b/arch/arm/dts/stm32mp157a-dk1.dts
@@ -39,12 +39,19 @@
 	};
 };
 
+&cec {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cec_pins_b>;
+	pinctrl-1 = <&cec_pins_sleep_b>;
+	status = "okay";
+};
+
 &ethernet0 {
 	status = "okay";
 	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
 	pinctrl-1 = <&ethernet0_rgmii_pins_sleep_a>;
 	pinctrl-names = "default", "sleep";
-	phy-mode = "rgmii";
+	phy-mode = "rgmii-id";
 	max-speed = <1000>;
 	phy-handle = <&phy0>;
 
@@ -64,6 +71,7 @@
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
 	status = "okay";
+	/* spare dmas for other usage */
 	/delete-property/dmas;
 	/delete-property/dma-names;
 
@@ -88,14 +96,11 @@
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
+		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
 
-		st,main-control-register = <0x04>;
-		st,vin-control-register = <0xc0>;
-		st,usb-control-register = <0x20>;
-
 		regulators {
 			compatible = "st,stpmic1-regulators";
 
@@ -107,7 +112,7 @@
 
 			vddcore: buck1 {
 				regulator-name = "vddcore";
-				regulator-min-microvolt = <1200000>;
+				regulator-min-microvolt = <800000>;
 				regulator-max-microvolt = <1350000>;
 				regulator-always-on;
 				regulator-initial-mode = <0>;
@@ -187,7 +192,6 @@
 				regulator-max-microvolt = <1200000>;
 				regulator-always-on;
 				interrupts = <IT_CURLIM_LDO6 0>;
-
 			};
 
 			vref_ddr: vref_ddr {
@@ -204,7 +208,6 @@
 			vbus_otg: pwr_sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
-				regulator-active-discharge;
 			 };
 
 			 vbus_sw: pwr_sw2 {
@@ -216,8 +219,9 @@
 
 		onkey {
 			compatible = "st,stpmic1-onkey";
-			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 1>;
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
 			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
 			status = "okay";
 		};
 
@@ -228,6 +232,10 @@
 	};
 };
 
+&ipcc {
+	status = "okay";
+};
+
 &iwdg2 {
 	timeout-sec = <32>;
 	status = "okay";
@@ -246,8 +254,10 @@
 };
 
 &sdmmc1 {
-	pinctrl-names = "default";
+	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
 	broken-cd;
 	st,neg-edge;
 	bus-width = <4>;
diff --git a/arch/arm/dts/stm32mp157c-dk2.dts b/arch/arm/dts/stm32mp157c-dk2.dts
index 9a81d2d472..020ea0f0e2 100644
--- a/arch/arm/dts/stm32mp157c-dk2.dts
+++ b/arch/arm/dts/stm32mp157c-dk2.dts
@@ -42,6 +42,7 @@
 		compatible = "orisetech,otm8009a";
 		reg = <0>;
 		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
+		power-supply = <&v3v3>;
 		status = "okay";
 
 		port {
diff --git a/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
index 55f99037b2..200601edff 100644
--- a/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
@@ -156,6 +156,10 @@
 	};
 };
 
+&sdmmc1 {
+	u-boot,dm-spl;
+};
+
 &sdmmc1_b4_pins_a {
 	u-boot,dm-spl;
 	pins {
@@ -165,12 +169,15 @@
 
 &sdmmc1_dir_pins_a {
 	u-boot,dm-spl;
-	pins {
+	pins1 {
+		u-boot,dm-spl;
+	};
+	pins2 {
 		u-boot,dm-spl;
 	};
 };
 
-&sdmmc1 {
+&sdmmc2 {
 	u-boot,dm-spl;
 };
 
@@ -188,10 +195,6 @@
 	};
 };
 
-&sdmmc2 {
-	u-boot,dm-spl;
-};
-
 &uart4 {
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/dts/stm32mp157c-ed1.dts b/arch/arm/dts/stm32mp157c-ed1.dts
index b10208f698..3d3f0c5cc9 100644
--- a/arch/arm/dts/stm32mp157c-ed1.dts
+++ b/arch/arm/dts/stm32mp157c-ed1.dts
@@ -19,6 +19,7 @@
 	};
 
 	memory@c0000000 {
+		device_type = "memory";
 		reg = <0xC0000000 0x40000000>;
 	};
 
@@ -40,7 +41,7 @@
 	};
 };
 
-&hwspinlock {
+&dts {
 	status = "okay";
 };
 
@@ -50,20 +51,18 @@
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
 	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
 
-	pmic: stpmic1@33 {
+	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
-		interrupts = <0 2>;
-		interrupt-parent = <&gpioa>;
+		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
 
-		st,main_control_register = <0x04>;
-		st,vin_control_register = <0xc0>;
-		st,usb_control_register = <0x30>;
-
 		regulators {
 			compatible = "st,stpmic1-regulators";
 
@@ -80,20 +79,8 @@
 				regulator-min-microvolt = <800000>;
 				regulator-max-microvolt = <1350000>;
 				regulator-always-on;
-				regulator-initial-mode = <2>;
+				regulator-initial-mode = <0>;
 				regulator-over-current-protection;
-
-				regulator-state-standby {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <1200000>;
-					regulator-mode = <8>;
-				};
-				regulator-state-mem {
-					regulator-off-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			vdd_ddr: buck2 {
@@ -101,22 +88,8 @@
 				regulator-min-microvolt = <1350000>;
 				regulator-max-microvolt = <1350000>;
 				regulator-always-on;
-				regulator-initial-mode = <2>;
+				regulator-initial-mode = <0>;
 				regulator-over-current-protection;
-
-				regulator-state-standby {
-					regulator-suspend-microvolt = <1350000>;
-					regulator-on-in-suspend;
-					regulator-mode = <8>;
-				};
-				regulator-state-mem {
-					regulator-suspend-microvolt = <1350000>;
-					regulator-on-in-suspend;
-					regulator-mode = <8>;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			vdd: buck3 {
@@ -124,46 +97,18 @@
 				regulator-min-microvolt = <3300000>;
 				regulator-max-microvolt = <3300000>;
 				regulator-always-on;
-				st,mask_reset;
-				regulator-initial-mode = <8>;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
 				regulator-over-current-protection;
-
-				regulator-state-standby {
-					regulator-suspend-microvolt = <3300000>;
-					regulator-on-in-suspend;
-					regulator-mode = <8>;
-				};
-				regulator-state-mem {
-					regulator-suspend-microvolt = <3300000>;
-					regulator-on-in-suspend;
-					regulator-mode = <8>;
-				};
-				regulator-state-disk {
-					regulator-suspend-microvolt = <3300000>;
-					regulator-on-in-suspend;
-					regulator-mode = <8>;
-				};
 			};
 
 			v3v3: buck4 {
 				regulator-name = "v3v3";
 				regulator-min-microvolt = <3300000>;
 				regulator-max-microvolt = <3300000>;
-				regulator-boot-on;
+				regulator-always-on;
 				regulator-over-current-protection;
-				regulator-initial-mode = <8>;
-
-				regulator-state-standby {
-					regulator-suspend-microvolt = <3300000>;
-					regulator-unchanged-in-suspend;
-					regulator-mode = <8>;
-				};
-				regulator-state-mem {
-					regulator-off-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
+				regulator-initial-mode = <0>;
 			};
 
 			vdda: ldo1 {
@@ -171,18 +116,6 @@
 				regulator-min-microvolt = <2900000>;
 				regulator-max-microvolt = <2900000>;
 				interrupts = <IT_CURLIM_LDO1 0>;
-				interrupt-parent = <&pmic>;
-
-				regulator-state-standby {
-					regulator-suspend-microvolt = <2900000>;
-					regulator-unchanged-in-suspend;
-				};
-				regulator-state-mem {
-					regulator-off-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			v2v8: ldo2 {
@@ -190,36 +123,14 @@
 				regulator-min-microvolt = <2800000>;
 				regulator-max-microvolt = <2800000>;
 				interrupts = <IT_CURLIM_LDO2 0>;
-				interrupt-parent = <&pmic>;
-
-				regulator-state-standby {
-					regulator-suspend-microvolt = <2800000>;
-					regulator-unchanged-in-suspend;
-				};
-				regulator-state-mem {
-					regulator-off-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			vtt_ddr: ldo3 {
 				regulator-name = "vtt_ddr";
-				regulator-min-microvolt = <0000000>;
-				regulator-max-microvolt = <1000000>;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
 				regulator-always-on;
 				regulator-over-current-protection;
-
-				regulator-state-standby {
-					regulator-off-in-suspend;
-				};
-				regulator-state-mem {
-					regulator-off-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			vdd_usb: ldo4 {
@@ -227,17 +138,6 @@
 				regulator-min-microvolt = <3300000>;
 				regulator-max-microvolt = <3300000>;
 				interrupts = <IT_CURLIM_LDO4 0>;
-				interrupt-parent = <&pmic>;
-
-				regulator-state-standby {
-					regulator-unchanged-in-suspend;
-				};
-				regulator-state-mem {
-					regulator-off-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			vdd_sd: ldo5 {
@@ -245,19 +145,7 @@
 				regulator-min-microvolt = <2900000>;
 				regulator-max-microvolt = <2900000>;
 				interrupts = <IT_CURLIM_LDO5 0>;
-				interrupt-parent = <&pmic>;
 				regulator-boot-on;
-
-				regulator-state-standby {
-					regulator-suspend-microvolt = <2900000>;
-					regulator-unchanged-in-suspend;
-				};
-				regulator-state-mem {
-					regulator-off-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			v1v8: ldo6 {
@@ -265,66 +153,54 @@
 				regulator-min-microvolt = <1800000>;
 				regulator-max-microvolt = <1800000>;
 				interrupts = <IT_CURLIM_LDO6 0>;
-				interrupt-parent = <&pmic>;
-
-				regulator-state-standby {
-					regulator-suspend-microvolt = <1800000>;
-					regulator-unchanged-in-suspend;
-				};
-				regulator-state-mem {
-					regulator-off-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			vref_ddr: vref_ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
 				regulator-over-current-protection;
-
-				regulator-state-standby {
-					regulator-on-in-suspend;
-				};
-				regulator-state-mem {
-					regulator-on-in-suspend;
-				};
-				regulator-state-disk {
-					regulator-off-in-suspend;
-				};
 			};
 
 			 bst_out: boost {
 				regulator-name = "bst_out";
 				interrupts = <IT_OCP_BOOST 0>;
-				interrupt-parent = <&pmic>;
 			 };
 
 			vbus_otg: pwr_sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
-				interrupt-parent = <&pmic>;
-				regulator-active-discharge;
 			 };
 
 			 vbus_sw: pwr_sw2 {
 				regulator-name = "vbus_sw";
 				interrupts = <IT_OCP_SWOUT 0>;
-				interrupt-parent = <&pmic>;
 				regulator-active-discharge;
 			 };
 		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+
 	};
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
+&ipcc {
 	status = "okay";
 };
 
-&pinctrl {
-	hwlocks = <&hwspinlock 0>;
+&iwdg2 {
+	timeout-sec = <32>;
+	status = "okay";
 };
 
 &pwr {
@@ -340,7 +216,10 @@
 };
 
 &sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
 	broken-cd;
 	st,sig-dir;
 	st,neg-edge;
@@ -348,11 +227,6 @@
 	bus-width = <4>;
 	vmmc-supply = <&vdd_sd>;
 	vqmmc-supply = <&sd_switch>;
-	sd-uhs-sdr12;
-	sd-uhs-sdr25;
-	sd-uhs-sdr50;
-	sd-uhs-ddr50;
-	sd-uhs-sdr104;
 	status = "okay";
 };
 
@@ -371,6 +245,9 @@
 
 &timers6 {
 	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	timer@5 {
 		status = "okay";
 	};
@@ -382,6 +259,10 @@
 	status = "okay";
 };
 
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
 &usbphyc_port0 {
 	phy-supply = <&vdd_usb>;
 };
diff --git a/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
index 994092a195..b656eb120d 100644
--- a/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
@@ -56,6 +56,3 @@
 	};
 };
 
-&v3v3 {
-	regulator-always-on;
-};
diff --git a/arch/arm/dts/stm32mp157c-ev1.dts b/arch/arm/dts/stm32mp157c-ev1.dts
index 663e52aa31..ca2a333d43 100644
--- a/arch/arm/dts/stm32mp157c-ev1.dts
+++ b/arch/arm/dts/stm32mp157c-ev1.dts
@@ -6,6 +6,7 @@
 /dts-v1/;
 
 #include "stm32mp157c-ed1.dts"
+#include <dt-bindings/gpio/gpio.h>
 
 / {
 	model = "STMicroelectronics STM32MP157C eval daughter on eval mother";
@@ -157,8 +158,9 @@
 };
 
 &m_can1 {
-	pinctrl-names = "default";
+	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
 	status = "okay";
 };
 
@@ -194,6 +196,9 @@
 };
 
 &timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "disabled";
 	pwm {
 		pinctrl-0 = <&pwm2_pins_a>;
@@ -206,6 +211,8 @@
 };
 
 &timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "disabled";
 	pwm {
 		pinctrl-0 = <&pwm8_pins_a>;
@@ -218,6 +225,8 @@
 };
 
 &timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "disabled";
 	pwm {
 		pinctrl-0 = <&pwm12_pins_a>;
@@ -232,7 +241,6 @@
 &usbh_ehci {
 	phys = <&usbphyc_port0>;
 	phy-names = "usb";
-	vbus-supply = <&vbus_sw>;
 	status = "okay";
 };
 
diff --git a/arch/arm/dts/stm32mp157c.dtsi b/arch/arm/dts/stm32mp157c.dtsi
index 73215855cc..38419c93ae 100644
--- a/arch/arm/dts/stm32mp157c.dtsi
+++ b/arch/arm/dts/stm32mp157c.dtsi
@@ -35,28 +35,6 @@
 		cpu_on = <0x84000003>;
 	};
 
-	aliases {
-		gpio0 = &gpioa;
-		gpio1 = &gpiob;
-		gpio2 = &gpioc;
-		gpio3 = &gpiod;
-		gpio4 = &gpioe;
-		gpio5 = &gpiof;
-		gpio6 = &gpiog;
-		gpio7 = &gpioh;
-		gpio8 = &gpioi;
-		gpio9 = &gpioj;
-		gpio10 = &gpiok;
-		serial0 = &usart1;
-		serial1 = &usart2;
-		serial2 = &usart3;
-		serial3 = &uart4;
-		serial4 = &uart5;
-		serial5 = &usart6;
-		serial6 = &uart7;
-		serial7 = &uart8;
-	};
-
 	intc: interrupt-controller@a0021000 {
 		compatible = "arm,cortex-a7-gic";
 		#interrupt-cells = <3>;
@@ -106,6 +84,38 @@
 		};
 	};
 
+	thermal-zones {
+		cpu_thermal: cpu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&dts>;
+
+			trips {
+				cpu_alert1: cpu-alert1 {
+					temperature = <85000>;
+					hysteresis = <0>;
+					type = "passive";
+				};
+
+				cpu-crit {
+					temperature = <120000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+			};
+		};
+	};
+
+	reboot {
+		compatible = "syscon-reboot";
+		regmap = <&rcc>;
+		offset = <0x404>;
+		mask = <0x1>;
+	};
+
 	soc {
 		compatible = "simple-bus";
 		#address-cells = <1>;
@@ -120,6 +130,12 @@
 			reg = <0x40000000 0x400>;
 			clocks = <&rcc TIM2_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 18 0x400 0x1>,
+			       <&dmamux1 19 0x400 0x1>,
+			       <&dmamux1 20 0x400 0x1>,
+			       <&dmamux1 21 0x400 0x1>,
+			       <&dmamux1 22 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up";
 			status = "disabled";
 
 			pwm {
@@ -141,6 +157,13 @@
 			reg = <0x40001000 0x400>;
 			clocks = <&rcc TIM3_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 23 0x400 0x1>,
+			       <&dmamux1 24 0x400 0x1>,
+			       <&dmamux1 25 0x400 0x1>,
+			       <&dmamux1 26 0x400 0x1>,
+			       <&dmamux1 27 0x400 0x1>,
+			       <&dmamux1 28 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
 			status = "disabled";
 
 			pwm {
@@ -162,6 +185,11 @@
 			reg = <0x40002000 0x400>;
 			clocks = <&rcc TIM4_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 29 0x400 0x1>,
+			       <&dmamux1 30 0x400 0x1>,
+			       <&dmamux1 31 0x400 0x1>,
+			       <&dmamux1 32 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4";
 			status = "disabled";
 
 			pwm {
@@ -183,6 +211,13 @@
 			reg = <0x40003000 0x400>;
 			clocks = <&rcc TIM5_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 55 0x400 0x1>,
+			       <&dmamux1 56 0x400 0x1>,
+			       <&dmamux1 57 0x400 0x1>,
+			       <&dmamux1 58 0x400 0x1>,
+			       <&dmamux1 59 0x400 0x1>,
+			       <&dmamux1 60 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
 			status = "disabled";
 
 			pwm {
@@ -204,6 +239,8 @@
 			reg = <0x40004000 0x400>;
 			clocks = <&rcc TIM6_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 69 0x400 0x1>;
+			dma-names = "up";
 			status = "disabled";
 
 			timer@5 {
@@ -220,6 +257,8 @@
 			reg = <0x40005000 0x400>;
 			clocks = <&rcc TIM7_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 70 0x400 0x1>;
+			dma-names = "up";
 			status = "disabled";
 
 			timer@6 {
@@ -347,6 +386,19 @@
 			status = "disabled";
 		};
 
+		spdifrx: audio-controller@4000d000 {
+			compatible = "st,stm32h7-spdifrx";
+			#sound-dai-cells = <0>;
+			reg = <0x4000d000 0x400>;
+			clocks = <&rcc SPDIF_K>;
+			clock-names = "kclk";
+			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 93 0x400 0x01>,
+			       <&dmamux1 94 0x400 0x01>;
+			dma-names = "rx", "rx-ctrl";
+			status = "disabled";
+		};
+
 		usart2: serial@4000e000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x4000e000 0x400>;
@@ -487,6 +539,15 @@
 			reg = <0x44000000 0x400>;
 			clocks = <&rcc TIM1_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 11 0x400 0x1>,
+			       <&dmamux1 12 0x400 0x1>,
+			       <&dmamux1 13 0x400 0x1>,
+			       <&dmamux1 14 0x400 0x1>,
+			       <&dmamux1 15 0x400 0x1>,
+			       <&dmamux1 16 0x400 0x1>,
+			       <&dmamux1 17 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4",
+				    "up", "trig", "com";
 			status = "disabled";
 
 			pwm {
@@ -508,6 +569,15 @@
 			reg = <0x44001000 0x400>;
 			clocks = <&rcc TIM8_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 47 0x400 0x1>,
+			       <&dmamux1 48 0x400 0x1>,
+			       <&dmamux1 49 0x400 0x1>,
+			       <&dmamux1 50 0x400 0x1>,
+			       <&dmamux1 51 0x400 0x1>,
+			       <&dmamux1 52 0x400 0x1>,
+			       <&dmamux1 53 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4",
+				    "up", "trig", "com";
 			status = "disabled";
 
 			pwm {
@@ -565,6 +635,11 @@
 			reg = <0x44006000 0x400>;
 			clocks = <&rcc TIM15_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 105 0x400 0x1>,
+			       <&dmamux1 106 0x400 0x1>,
+			       <&dmamux1 107 0x400 0x1>,
+			       <&dmamux1 108 0x400 0x1>;
+			dma-names = "ch1", "up", "trig", "com";
 			status = "disabled";
 
 			pwm {
@@ -586,6 +661,9 @@
 			reg = <0x44007000 0x400>;
 			clocks = <&rcc TIM16_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 109 0x400 0x1>,
+			       <&dmamux1 110 0x400 0x1>;
+			dma-names = "ch1", "up";
 			status = "disabled";
 
 			pwm {
@@ -606,6 +684,9 @@
 			reg = <0x44008000 0x400>;
 			clocks = <&rcc TIM17_K>;
 			clock-names = "int";
+			dmas = <&dmamux1 111 0x400 0x1>,
+			       <&dmamux1 112 0x400 0x1>;
+			dma-names = "ch1", "up";
 			status = "disabled";
 
 			pwm {
@@ -706,14 +787,14 @@
 
 		m_can1: can@4400e000 {
 			compatible = "bosch,m_can";
-			reg = <0x4400e000 0x400>, <0x44011000 0x2800>;
+			reg = <0x4400e000 0x400>, <0x44011000 0x1400>;
 			reg-names = "m_can", "message_ram";
 			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "int0", "int1";
 			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
 			clock-names = "hclk", "cclk";
-			bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
 			status = "disabled";
 		};
 
@@ -811,13 +892,14 @@
 		};
 
 		sdmmc3: sdmmc@48004000 {
-			compatible = "st,stm32-sdmmc2";
-			reg = <0x48004000 0x400>, <0x48005000 0x400>;
-			reg-names = "sdmmc", "delay";
+			compatible = "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x10153180>;
+			reg = <0x48004000 0x400>;
+			reg-names = "sdmmc";
 			interrupts = <GIC_SPI 137 IRQ_TYPE_NONE>;
 			clocks = <&rcc SDMMC3_K>;
+			clock-names = "apb_pclk";
 			resets = <&rcc SDMMC3_R>;
-			st,idma = <1>;
 			cap-sd-highspeed;
 			cap-mmc-highspeed;
 			max-frequency = <120000000>;
@@ -825,7 +907,7 @@
 		};
 
 		usbotg_hs: usb-otg@49000000 {
-			compatible = "st,stm32mp1-hsotg", "snps,dwc2";
+			compatible = "snps,dwc2";
 			reg = <0x49000000 0x10000>;
 			clocks = <&rcc USBO_K>;
 			clock-names = "otg";
@@ -849,6 +931,21 @@
 			status = "disabled";
 		};
 
+		ipcc: mailbox@4c001000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x4c001000 0x400>;
+			st,proc-id = <0>;
+			interrupts-extended =
+				<&intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+				<&exti 61 1>;
+			interrupt-names = "rx", "tx", "wakeup";
+			clocks = <&rcc IPCC>;
+			wakeup-source;
+			status = "disabled";
+		};
+
 		rcc: rcc@50000000 {
 			compatible = "st,stm32mp1-rcc", "syscon";
 			reg = <0x50000000 0x1000>;
@@ -856,13 +953,6 @@
 			#reset-cells = <1>;
 		};
 
-		rcc_reboot: rcc-reboot@50000000 {
-			compatible = "syscon-reboot";
-			regmap = <&rcc>;
-			offset = <0x404>;
-			mask = <0x1>;
-		};
-
 		pwr: pwr@50001000 {
 			compatible = "st,stm32mp1-pwr", "st,stm32-pwr", "syscon", "simple-mfd";
 			reg = <0x50001000 0x400>;
@@ -872,7 +962,7 @@
 			clocks = <&rcc PLL2_R>;
 			clock-names = "phyclk";
 
-			pwr-regulators@c {
+			pwr-regulators {
 				compatible = "st,stm32mp1,pwr-reg";
 				st,tzcr = <&rcc 0x0 0x1>;
 
@@ -906,6 +996,7 @@
 		syscfg: syscon@50020000 {
 			compatible = "st,stm32mp157-syscfg", "syscon";
 			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
 		};
 
 		lptimer2: timer@50021000 {
@@ -994,6 +1085,16 @@
 			status = "disabled";
 		};
 
+		dts: thermal@50028000 {
+			compatible = "st,stm32-thermal";
+			reg = <0x50028000 0x100>;
+			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc TMPSENS>;
+			clock-names = "pclk";
+			#thermal-sensor-cells = <0>;
+			status = "disabled";
+		};
+
 		cryp1: cryp@54001000 {
 			compatible = "st,stm32mp1-cryp";
 			reg = <0x54001000 0x400>;
@@ -1059,12 +1160,14 @@
 		};
 
 		sdmmc1: sdmmc@58005000 {
-			compatible = "st,stm32-sdmmc2";
-			reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
-			reg-names = "sdmmc", "delay";
+			compatible = "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x10153180>;
+			reg = <0x58005000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names	= "cmd_irq";
 			clocks = <&rcc SDMMC1_K>;
+			clock-names = "apb_pclk";
 			resets = <&rcc SDMMC1_R>;
-			st,idma = <1>;
 			cap-sd-highspeed;
 			cap-mmc-highspeed;
 			max-frequency = <120000000>;
@@ -1072,13 +1175,13 @@
 		};
 
 		sdmmc2: sdmmc@58007000 {
-			compatible = "st,stm32-sdmmc2";
-			reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
-			reg-names = "sdmmc", "delay";
+			compatible = "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x10153180>;
+			reg = <0x58007000 0x1000>;
 			interrupts = <GIC_SPI 124 IRQ_TYPE_NONE>;
 			clocks = <&rcc SDMMC2_K>;
+			clock-names = "apb_pclk";
 			resets = <&rcc SDMMC2_R>;
-			st,idma = <1>;
 			cap-sd-highspeed;
 			cap-mmc-highspeed;
 			max-frequency = <120000000>;
@@ -1102,25 +1205,21 @@
 			compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";
 			reg = <0x5800a000 0x2000>;
 			reg-names = "stmmaceth";
-			interrupts-extended =
-				<&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
-				<&intc GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
-				<&exti 70 1>;
-			interrupt-names = "macirq",
-					  "eth_wake_irq",
-					  "stm32_pwr_wakeup";
+			interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
 			clock-names = "stmmaceth",
 				      "mac-clk-tx",
 				      "mac-clk-rx",
-				      "ethstp";
+				      "ethstp",
+				      "syscfg-clk";
 			clocks = <&rcc ETHMAC>,
 				 <&rcc ETHTX>,
 				 <&rcc ETHRX>,
-				 <&rcc ETHSTP>;
+				 <&rcc ETHSTP>,
+				 <&rcc SYSCFG>;
 			st,syscon = <&syscfg 0x4>;
 			snps,mixed-burst;
 			snps,pbl = <2>;
-			snps,en-tx-lpi-clockgating;
 			snps,axi-config = <&stmmac_axi_config_0>;
 			snps,tso;
 			status = "disabled";
@@ -1245,6 +1344,12 @@
 			reg = <0x5c005000 0x400>;
 			#address-cells = <1>;
 			#size-cells = <1>;
+			ts_cal1: calib@5c {
+				reg = <0x5c 0x2>;
+			};
+			ts_cal2: calib@5e {
+				reg = <0x5e 0x2>;
+			};
 		};
 
 		i2c6: i2c@5c009000 {
diff --git a/arch/arm/mach-stm32mp/Kconfig b/arch/arm/mach-stm32mp/Kconfig
index d9ad6b423b..a4fc3c5f10 100644
--- a/arch/arm/mach-stm32mp/Kconfig
+++ b/arch/arm/mach-stm32mp/Kconfig
@@ -64,6 +64,16 @@ config STM32MP1_TRUSTED
 		BootRom => TF-A.stm32 (clock & DDR) => U-Boot.stm32
 		TF-A monitor provides proprietary smc to manage secure devices
 
+config STM32MP1_OPTEE
+	bool "Support trusted boot with TF-A and OPTEE"
+	depends on STM32MP1_TRUSTED
+	default n
+	help
+		Say Y here to enable boot with TF-A and OPTEE
+		Trusted boot chain is :
+		BootRom => TF-A.stm32 (clock & DDR) => OPTEE => U-Boot.stm32
+		OPTEE monitor provide ST smc to manage secure devices
+
 config SYS_TEXT_BASE
 	prompt "U-Boot base address"
 	default 0xC0100000
@@ -83,6 +93,21 @@ config SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_MMC2
 	  Partition on the second MMC to load U-Boot from when the MMC is being
 	  used in raw mode
 
+config STM32_ETZPC
+	bool "STM32 Extended TrustZone Protection"
+	depends on TARGET_STM32MP1
+	default y
+	help
+	  Say y to enable STM32 Extended TrustZone Protection
+
+config CMD_STM32KEY
+	bool "command stm32key to fuse public key hash"
+	default y
+	depends on CMD_FUSE
+	help
+		fuse public key hash in corresponding fuse used to authenticate
+		binary.
+
 config BOOTSTAGE_STASH_ADDR
 	default 0xC3000000
 
diff --git a/arch/arm/mach-stm32mp/Makefile b/arch/arm/mach-stm32mp/Makefile
index 1493914a11..77450604b0 100644
--- a/arch/arm/mach-stm32mp/Makefile
+++ b/arch/arm/mach-stm32mp/Makefile
@@ -11,9 +11,11 @@ ifdef CONFIG_SPL_BUILD
 obj-y += spl.o
 else
 obj-y += bsec.o
+obj-$(CONFIG_CMD_STM32KEY) += cmd_stm32key.o
 ifndef CONFIG_STM32MP1_TRUSTED
 obj-$(CONFIG_SYSRESET) += cmd_poweroff.o
 endif
 endif
 obj-$(CONFIG_ARMV7_PSCI) += psci.o
 obj-$(CONFIG_$(SPL_)DM_REGULATOR) += pwr_regulator.o
+obj-$(CONFIG_OF_SYSTEM_SETUP) += fdt.o
diff --git a/arch/arm/mach-stm32mp/cmd_stm32key.c b/arch/arm/mach-stm32mp/cmd_stm32key.c
new file mode 100644
index 0000000000..f1f26e7c94
--- /dev/null
+++ b/arch/arm/mach-stm32mp/cmd_stm32key.c
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2019, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <command.h>
+#include <console.h>
+#include <misc.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+
+#define STM32_OTP_HASH_KEY_START 24
+#define STM32_OTP_HASH_KEY_SIZE 8
+
+static void read_hash_value(u32 addr)
+{
+	int i;
+
+	for (i = 0; i < STM32_OTP_HASH_KEY_SIZE; i++) {
+		printf("OTP value %i: %x\n", STM32_OTP_HASH_KEY_START + i,
+		       __be32_to_cpu(*(u32 *)addr));
+		addr += 4;
+	}
+}
+
+static void fuse_hash_value(u32 addr, bool print)
+{
+	struct udevice *dev;
+	u32 word, val;
+	int i, ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_GET_DRIVER(stm32mp_bsec),
+					  &dev);
+	if (ret) {
+		pr_err("Can't find stm32mp_bsec driver\n");
+		return;
+	}
+
+	for (i = 0; i < STM32_OTP_HASH_KEY_SIZE; i++) {
+		if (print)
+			printf("Fuse OTP %i : %x\n",
+			       STM32_OTP_HASH_KEY_START + i,
+			       __be32_to_cpu(*(u32 *)addr));
+
+		word = STM32_OTP_HASH_KEY_START + i;
+		val = __be32_to_cpu(*(u32 *)addr);
+		misc_write(dev, STM32_BSEC_OTP(word), &val, 4);
+
+		addr += 4;
+	}
+}
+
+static int confirm_prog(void)
+{
+	puts("Warning: Programming fuses is an irreversible operation!\n"
+			"         This may brick your system.\n"
+			"         Use this command only if you are sure of what you are doing!\n"
+			"\nReally perform this fuse programming? <y/N>\n");
+
+	if (confirm_yesno())
+		return 1;
+
+	puts("Fuse programming aborted\n");
+	return 0;
+}
+
+static int do_stm32key(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	u32 addr;
+	const char *op = argc >= 2 ? argv[1] : NULL;
+	int confirmed = argc > 3 && !strcmp(argv[2], "-y");
+
+	argc -= 2 + confirmed;
+	argv += 2 + confirmed;
+
+	if (argc < 1)
+		return CMD_RET_USAGE;
+
+	addr = simple_strtoul(argv[0], NULL, 16);
+	if (!addr)
+		return CMD_RET_USAGE;
+
+	if (!strcmp(op, "read"))
+		read_hash_value(addr);
+
+	if (!strcmp(op, "fuse")) {
+		if (!confirmed && !confirm_prog())
+			return CMD_RET_FAILURE;
+		fuse_hash_value(addr, !confirmed);
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(stm32key, 4, 1, do_stm32key,
+	   "Fuse ST Hash key",
+	   "read <addr>: Read the hash store at addr in memory\n"
+	   "stm32key fuse [-y] <addr> : Fuse hash store at addr in otp\n");
diff --git a/arch/arm/mach-stm32mp/cpu.c b/arch/arm/mach-stm32mp/cpu.c
index e1a0a13680..d4f2ea821a 100644
--- a/arch/arm/mach-stm32mp/cpu.c
+++ b/arch/arm/mach-stm32mp/cpu.c
@@ -78,11 +78,6 @@
 #define PKG_SHIFT	27
 #define PKG_MASK	GENMASK(2, 0)
 
-#define PKG_AA_LBGA448	4
-#define PKG_AB_LBGA354	3
-#define PKG_AC_TFBGA361	2
-#define PKG_AD_TFBGA257	1
-
 #if !defined(CONFIG_SPL) || defined(CONFIG_SPL_BUILD)
 #ifndef CONFIG_STM32MP1_TRUSTED
 static void security_init(void)
@@ -277,7 +272,7 @@ u32 get_cpu_type(void)
 }
 
 /* Get Package options from OTP */
-static u32 get_cpu_package(void)
+u32 get_cpu_package(void)
 {
 	return get_otp(BSEC_OTP_PKG, PKG_SHIFT, PKG_MASK);
 }
diff --git a/arch/arm/mach-stm32mp/fdt.c b/arch/arm/mach-stm32mp/fdt.c
new file mode 100644
index 0000000000..82c430b7c7
--- /dev/null
+++ b/arch/arm/mach-stm32mp/fdt.c
@@ -0,0 +1,223 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2019, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <fdt_support.h>
+#include <asm/arch/sys_proto.h>
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+#include <linux/io.h>
+
+#define ETZPC_DECPROT(n)	(STM32_ETZPC_BASE + 0x10 + 4 * (n))
+#define ETZPC_DECPROT_NB	6
+
+#define DECPROT_MASK		0x03
+#define NB_PROT_PER_REG		0x10
+#define DECPROT_NB_BITS		2
+
+#define DECPROT_SECURED		0x00
+#define DECPROT_WRITE_SECURE	0x01
+#define DECPROT_MCU_ISOLATION	0x02
+#define DECPROT_NON_SECURED	0x03
+
+#define ETZPC_RESERVED		0xffffffff
+
+static const u32 stm32mp1_ip_addr[] = {
+	0x5c008000,	/* 00 stgenc */
+	0x54000000,	/* 01 bkpsram */
+	0x5c003000,	/* 02 iwdg1 */
+	0x5c000000,	/* 03 usart1 */
+	0x5c001000,	/* 04 spi6 */
+	0x5c002000,	/* 05 i2c4 */
+	ETZPC_RESERVED,	/* 06 reserved */
+	0x54003000,	/* 07 rng1 */
+	0x54002000,	/* 08 hash1 */
+	0x54001000,	/* 09 cryp1 */
+	0x5a003000,	/* 0A ddrctrl */
+	0x5a004000,	/* 0B ddrphyc */
+	0x5c009000,	/* 0C i2c6 */
+	ETZPC_RESERVED,	/* 0D reserved */
+	ETZPC_RESERVED,	/* 0E reserved */
+	ETZPC_RESERVED,	/* 0F reserved */
+	0x40000000,	/* 10 tim2 */
+	0x40001000,	/* 11 tim3 */
+	0x40002000,	/* 12 tim4 */
+	0x40003000,	/* 13 tim5 */
+	0x40004000,	/* 14 tim6 */
+	0x40005000,	/* 15 tim7 */
+	0x40006000,	/* 16 tim12 */
+	0x40007000,	/* 17 tim13 */
+	0x40008000,	/* 18 tim14 */
+	0x40009000,	/* 19 lptim1 */
+	0x4000a000,	/* 1A wwdg1 */
+	0x4000b000,	/* 1B spi2 */
+	0x4000c000,	/* 1C spi3 */
+	0x4000d000,	/* 1D spdifrx */
+	0x4000e000,	/* 1E usart2 */
+	0x4000f000,	/* 1F usart3 */
+	0x40010000,	/* 20 uart4 */
+	0x40011000,	/* 21 uart5 */
+	0x40012000,	/* 22 i2c1 */
+	0x40013000,	/* 23 i2c2 */
+	0x40014000,	/* 24 i2c3 */
+	0x40015000,	/* 25 i2c5 */
+	0x40016000,	/* 26 cec */
+	0x40017000,	/* 27 dac */
+	0x40018000,	/* 28 uart7 */
+	0x40019000,	/* 29 uart8 */
+	ETZPC_RESERVED,	/* 2A reserved */
+	ETZPC_RESERVED,	/* 2B reserved */
+	0x4001c000,	/* 2C mdios */
+	ETZPC_RESERVED,	/* 2D reserved */
+	ETZPC_RESERVED,	/* 2E reserved */
+	ETZPC_RESERVED,	/* 2F reserved */
+	0x44000000,	/* 30 tim1 */
+	0x44001000,	/* 31 tim8 */
+	ETZPC_RESERVED,	/* 32 reserved */
+	0x44003000,	/* 33 usart6 */
+	0x44004000,	/* 34 spi1 */
+	0x44005000,	/* 35 spi4 */
+	0x44006000,	/* 36 tim15 */
+	0x44007000,	/* 37 tim16 */
+	0x44008000,	/* 38 tim17 */
+	0x44009000,	/* 39 spi5 */
+	0x4400a000,	/* 3A sai1 */
+	0x4400b000,	/* 3B sai2 */
+	0x4400c000,	/* 3C sai3 */
+	0x4400d000,	/* 3D dfsdm */
+	0x4400e000,	/* 3E tt_fdcan */
+	ETZPC_RESERVED,	/* 3F reserved */
+	0x50021000,	/* 40 lptim2 */
+	0x50022000,	/* 41 lptim3 */
+	0x50023000,	/* 42 lptim4 */
+	0x50024000,	/* 43 lptim5 */
+	0x50027000,	/* 44 sai4 */
+	0x50025000,	/* 45 vrefbuf */
+	0x4c006000,	/* 46 dcmi */
+	0x4c004000,	/* 47 crc2 */
+	0x48003000,	/* 48 adc */
+	0x4c002000,	/* 49 hash2 */
+	0x4c003000,	/* 4A rng2 */
+	0x4c005000,	/* 4B cryp2 */
+	ETZPC_RESERVED,	/* 4C reserved */
+	ETZPC_RESERVED,	/* 4D reserved */
+	ETZPC_RESERVED,	/* 4E reserved */
+	ETZPC_RESERVED,	/* 4F reserved */
+	ETZPC_RESERVED,	/* 50 sram1 */
+	ETZPC_RESERVED,	/* 51 sram2 */
+	ETZPC_RESERVED,	/* 52 sram3 */
+	ETZPC_RESERVED,	/* 53 sram4 */
+	ETZPC_RESERVED,	/* 54 retram */
+	0x49000000,	/* 55 otg */
+	0x48004000,	/* 56 sdmmc3 */
+	0x48005000,	/* 57 dlybsd3 */
+	0x48000000,	/* 58 dma1 */
+	0x48001000,	/* 59 dma2 */
+	0x48002000,	/* 5A dmamux */
+	0x58002000,	/* 5B fmc */
+	0x58003000,	/* 5C qspi */
+	0x58004000,	/* 5D dlybq */
+	0x5800a000,	/* 5E eth */
+	ETZPC_RESERVED,	/* 5F reserved */
+};
+
+/* fdt helper */
+static bool fdt_disable_subnode_by_address(void *fdt, int offset, u32 addr)
+{
+	int node;
+
+	for (node = fdt_first_subnode(fdt, offset);
+	     node >= 0;
+	     node = fdt_next_subnode(fdt, node)) {
+		if (addr == (u32)fdt_getprop(fdt, node, "reg", 0)) {
+			if (fdtdec_get_is_enabled(fdt, node)) {
+				fdt_status_disabled(fdt, node);
+
+				return true;
+			}
+			return false;
+		}
+	}
+
+	return false;
+}
+
+static int stm32_fdt_fixup_etzpc(void *fdt)
+{
+	const u32 *array;
+	int array_size, i;
+	int soc_node, offset, shift;
+	u32 addr, status, decprot[ETZPC_DECPROT_NB];
+
+	array = stm32mp1_ip_addr;
+	array_size = ARRAY_SIZE(stm32mp1_ip_addr);
+
+	for (i = 0; i < ETZPC_DECPROT_NB; i++)
+		decprot[i] = readl(ETZPC_DECPROT(i));
+
+	soc_node = fdt_path_offset(fdt, "/soc");
+	if (soc_node < 0)
+		return soc_node;
+
+	for (i = 0; i < array_size; i++) {
+		offset = i / NB_PROT_PER_REG;
+		shift = (i % NB_PROT_PER_REG) * DECPROT_NB_BITS;
+		status = (decprot[offset] >> shift) & DECPROT_MASK;
+		addr = array[i];
+
+		debug("ETZPC: 0x%08x decprot %d=%d\n", addr, i, status);
+
+		if (addr == ETZPC_RESERVED ||
+		    status == DECPROT_NON_SECURED)
+			continue;
+
+		if (fdt_disable_subnode_by_address(fdt, soc_node, addr))
+			printf("ETZPC: 0x%08x node disabled, decprot %d=%d\n",
+			       addr, i, status);
+	}
+
+	return 0;
+}
+
+/*
+ * This function is called right before the kernel is booted. "blob" is the
+ * device tree that will be passed to the kernel.
+ */
+int ft_system_setup(void *blob, bd_t *bd)
+{
+	int ret = 0;
+	u32 pkg;
+
+	if (CONFIG_IS_ENABLED(STM32_ETZPC)) {
+		ret = stm32_fdt_fixup_etzpc(blob);
+		if (ret)
+			return ret;
+	}
+
+	switch (get_cpu_package()) {
+	case PKG_AA_LBGA448:
+		pkg = STM32MP_PKG_AA;
+		break;
+	case PKG_AB_LBGA354:
+		pkg = STM32MP_PKG_AB;
+		break;
+	case PKG_AC_TFBGA361:
+		pkg = STM32MP_PKG_AC;
+		break;
+	case PKG_AD_TFBGA257:
+		pkg = STM32MP_PKG_AD;
+		break;
+	default:
+		pkg = 0;
+		break;
+	}
+	if (pkg) {
+		do_fixup_by_compat_u32(blob, "st,stm32mp157-pinctrl",
+				       "st,package", pkg, false);
+		do_fixup_by_compat_u32(blob, "st,stm32mp157-z-pinctrl",
+				       "st,package", pkg, false);
+	}
+
+	return ret;
+}
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32.h b/arch/arm/mach-stm32mp/include/mach/stm32.h
index 6795352044..1d4b5482ac 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32.h
@@ -15,6 +15,7 @@
 #define STM32_DBGMCU_BASE		0x50081000
 #define STM32_TZC_BASE			0x5C006000
 #define STM32_ETZPC_BASE		0x5C007000
+#define STM32_STGEN_BASE		0x5C008000
 #define STM32_TAMP_BASE			0x5C00A000
 
 #define STM32_USART1_BASE		0x5C000000
@@ -36,9 +37,7 @@
 /* enumerated used to identify the SYSCON driver instance */
 enum {
 	STM32MP_SYSCON_UNKNOWN,
-	STM32MP_SYSCON_ETZPC,
 	STM32MP_SYSCON_PWR,
-	STM32MP_SYSCON_STGEN,
 	STM32MP_SYSCON_SYSCFG,
 };
 
diff --git a/arch/arm/mach-stm32mp/include/mach/sys_proto.h b/arch/arm/mach-stm32mp/include/mach/sys_proto.h
index 71a3ba794d..99eefabf6e 100644
--- a/arch/arm/mach-stm32mp/include/mach/sys_proto.h
+++ b/arch/arm/mach-stm32mp/include/mach/sys_proto.h
@@ -19,5 +19,14 @@ u32 get_cpu_type(void);
 
 /* return CPU_REV constants */
 u32 get_cpu_rev(void);
+
+/* Get Package options from OTP */
+u32 get_cpu_package(void);
+
+#define PKG_AA_LBGA448	4
+#define PKG_AB_LBGA354	3
+#define PKG_AC_TFBGA361	2
+#define PKG_AD_TFBGA257	1
+
 /* return boot mode */
 u32 get_bootmode(void);
diff --git a/arch/arm/mach-stm32mp/syscon.c b/arch/arm/mach-stm32mp/syscon.c
index 242f8340ab..6070837bf0 100644
--- a/arch/arm/mach-stm32mp/syscon.c
+++ b/arch/arm/mach-stm32mp/syscon.c
@@ -9,9 +9,7 @@
 #include <asm/arch/stm32.h>
 
 static const struct udevice_id stm32mp_syscon_ids[] = {
-	{ .compatible = "st,stm32mp1-etzpc", .data = STM32MP_SYSCON_ETZPC },
 	{ .compatible = "st,stm32mp1-pwr", .data = STM32MP_SYSCON_PWR },
-	{ .compatible = "st,stm32-stgen", .data = STM32MP_SYSCON_STGEN },
 	{ .compatible = "st,stm32mp157-syscfg",
 	  .data = STM32MP_SYSCON_SYSCFG },
 	{ }
diff --git a/board/st/stm32mp1/Kconfig b/board/st/stm32mp1/Kconfig
index 5ab94151a9..92d8f901ff 100644
--- a/board/st/stm32mp1/Kconfig
+++ b/board/st/stm32mp1/Kconfig
@@ -9,4 +9,11 @@ config SYS_VENDOR
 config SYS_CONFIG_NAME
 	default "stm32mp1"
 
+config CMD_STBOARD
+	bool "stboard - command for OTP board information"
+	default y
+	help
+	  This compile the stboard command to
+	  read and write the board in the OTP.
+
 endif
diff --git a/board/st/stm32mp1/MAINTAINERS b/board/st/stm32mp1/MAINTAINERS
index 0a2eddbe03..5cbf048376 100644
--- a/board/st/stm32mp1/MAINTAINERS
+++ b/board/st/stm32mp1/MAINTAINERS
@@ -6,4 +6,5 @@ F:	arch/arm/dts/stm32mp157*
 F:	board/st/stm32mp1
 F:	configs/stm32mp15_basic_defconfig
 F:	configs/stm32mp15_trusted_defconfig
+F:	configs/stm32mp15_optee_defconfig
 F:	include/configs/stm32mp1.h
diff --git a/board/st/stm32mp1/Makefile b/board/st/stm32mp1/Makefile
index 8188075b1a..3c6c035b11 100644
--- a/board/st/stm32mp1/Makefile
+++ b/board/st/stm32mp1/Makefile
@@ -7,6 +7,7 @@ ifdef CONFIG_SPL_BUILD
 obj-y += spl.o
 else
 obj-y += stm32mp1.o
+obj-$(CONFIG_CMD_STBOARD) += cmd_stboard.o
 endif
 
 obj-y += board.o
diff --git a/board/st/stm32mp1/README b/board/st/stm32mp1/README
index b0c8325061..41c76207be 100644
--- a/board/st/stm32mp1/README
+++ b/board/st/stm32mp1/README
@@ -25,6 +25,10 @@ It features:
 Everything is supported in Linux but U-Boot is limited to:
 1. UART
 2. SDCard/MMC controller (SDMMC)
+3. NAND controller (FMC)
+4. NOR controller (QSPI)
+5. USB controller (OTG DWC2)
+6. Ethernet controller
 
 And the necessary drivers
 1. I2C
@@ -47,20 +51,27 @@ BootRom => FSBL in SYSRAM => SSBL in DDR => OS (Linux Kernel)
 with FSBL = First Stage Bootloader
      SSBL = Second Stage Bootloader
 
-2 boot configurations are supported:
+3 boot configurations are supported:
 
 1) The "Trusted" boot chain (defconfig_file : stm32mp15_trusted_defconfig)
    BootRom => FSBL = Trusted Firmware-A (TF-A) => SSBL = U-Boot
    TF-A performs a full initialization of Secure peripherals and installs a
    secure monitor.
    U-Boot is running in normal world and uses TF-A monitor
-   to access to secure resources
+   to access to secure resources.
 
-2) The "Basic" boot chain (defconfig_file : stm32mp15_basic_defconfig)
+2) The "Trusted & OP-TEE" boot chain
+   (defconfig_file : stm32mp15_optee_defconfig)
+   BootRom => FSBL = Trusted Firmware-A (TF-A) => SSBL = U-Boot
+   TF-A performs a full initialization of Secure peripherals and installs OP-TEE
+   from specific partitions (teeh, teed, teex).
+   U-Boot is running in normal world and uses OP-TEE monitor to access.
+
+3) The "Basic" boot chain (defconfig_file : stm32mp15_basic_defconfig)
    BootRom => FSBL = U-Boot SPL => SSBL = U-Boot
    SPL has limited security initialisation
    U-Boot is running in secure mode and provide a secure monitor to the kernel
-   with only PSCI support (Power State Coordination Interface defined by ARM)
+   with only PSCI support (Power State Coordination Interface defined by ARM).
 
 All the STM32MP1 boards supported by U-Boot use the same generic board
 stm32mp1 which support all the bootable devices.
@@ -109,13 +120,18 @@ the supported device trees for stm32mp157 are:
 
 	for example: use one output directory for each configuration
 	# export KBUILD_OUTPUT=stm32mp15_trusted
+	# export KBUILD_OUTPUT=stm32mp15_optee
 	# export KBUILD_OUTPUT=stm32mp15_basic
 
+	you can build outside of code directory:
+	# export KBUILD_OUTPUT=../build/stm32mp15_trusted
+
 4. Configure U-Boot:
 
 	# make <defconfig_file>
 
 	- For trusted boot mode : "stm32mp15_trusted_defconfig"
+	- For trusted & optee boot mode : "stm32mp15_optee_defconfig"
 	- For basic boot mode: "stm32mp15_basic_defconfig"
 
 5. Configure the device-tree and build the U-Boot image:
@@ -129,22 +145,27 @@ the supported device trees for stm32mp157 are:
 	# make stm32mp15_trusted_defconfig
 	# make DEVICE_TREE=stm32mp157c-ev1 all
 
-  b) basic boot on ev1
+  b) trusted & OP-TEE boot on dk1
+	# export KBUILD_OUTPUT=stm32mp15_optee
+	# make stm32mp15_optee_defconfig
+	# make DEVICE_TREE=stm32mp157a-dk1 all
+
+  c) basic boot on ev1
 	# export KBUILD_OUTPUT=stm32mp15_basic
 	# make stm32mp15_basic_defconfig
 	# make DEVICE_TREE=stm32mp157c-ev1 all
 
-  c) basic boot on ed1
+  d) basic boot on ed1
 	# export KBUILD_OUTPUT=stm32mp15_basic
 	# make stm32mp15_basic_defconfig
 	# make DEVICE_TREE=stm32mp157c-ed1 all
 
-  d) basic boot on dk2
+  e) basic boot on dk2
 	# export KBUILD_OUTPUT=stm32mp15_basic
 	# make stm32mp15_basic_defconfig
 	# make DEVICE_TREE=stm32mp157c-dk2 all
 
-  d) basic boot on avenger96
+  f) basic boot on avenger96
 	# export KBUILD_OUTPUT=stm32mp15_basic
 	# make stm32mp15_basic_defconfig
 	# make DEVICE_TREE=stm32mp157a-avenger96 all
@@ -157,7 +178,7 @@ the supported device trees for stm32mp157 are:
   So in the output directory (selected by KBUILD_OUTPUT),
   you can found the needed files:
 
-  a) For Trusted boot
+  a) For Trusted boot (with or without OP-TEE)
    + FSBL = tf-a.stm32 (provided by TF-A compilation)
    + SSBL = u-boot.stm32
 
@@ -170,6 +191,8 @@ the supported device trees for stm32mp157 are:
 
 You can select the boot mode, on the board ed1 with the switch SW1
 
+- on the daugther board ed1 with the switch SW1 : BOOT0, BOOT1, BOOT2
+
  -----------------------------------
   Boot Mode   BOOT2   BOOT1   BOOT0
  -----------------------------------
@@ -267,7 +290,7 @@ for example: with gpt table with 128 entries
 	# dd if=tf-a.stm32 of=/dev/mmcblk0p2
 	# dd if=u-boot.stm32 of=/dev/mmcblk0p3
 
-To boot from SDCard, select BootPinMode = 1 1 1 and reset.
+To boot from SDCard, select BootPinMode = 1 0 1 and reset.
 
 8. Prepare eMMC
 ===============
diff --git a/board/st/stm32mp1/cmd_stboard.c b/board/st/stm32mp1/cmd_stboard.c
new file mode 100644
index 0000000000..f781c364cf
--- /dev/null
+++ b/board/st/stm32mp1/cmd_stboard.c
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2019, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <console.h>
+#include <misc.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+
+static bool check_stboard(u16 board)
+{
+	unsigned int i;
+	const u16 st_board_id[] = {
+		0x1272,
+		0x1263,
+		0x1264,
+		0x1298,
+		0x1341,
+		0x1497,
+	};
+
+	for (i = 0; i < ARRAY_SIZE(st_board_id); i++)
+		if (board == st_board_id[i])
+			return true;
+
+	return false;
+}
+
+static void display_stboard(u32 otp)
+{
+	printf("Board: MB%04x Var%d Rev.%c-%02d\n",
+	       otp >> 16,
+	       (otp >> 12) & 0xF,
+	       ((otp >> 8) & 0xF) - 1 + 'A',
+	       otp & 0xF);
+}
+
+static int do_stboard(cmd_tbl_t *cmdtp, int flag, int argc,
+		      char * const argv[])
+{
+	int ret;
+	u32 otp;
+	u8 revision;
+	unsigned long board, variant, bom;
+	struct udevice *dev;
+	int confirmed = argc == 6 && !strcmp(argv[1], "-y");
+
+	argc -= 1 + confirmed;
+	argv += 1 + confirmed;
+
+	if (argc != 0 && argc != 4)
+		return CMD_RET_USAGE;
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_GET_DRIVER(stm32mp_bsec),
+					  &dev);
+
+	ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_BOARD),
+			&otp, sizeof(otp));
+
+	if (ret) {
+		puts("OTP read error");
+		return CMD_RET_FAILURE;
+	}
+
+	if (argc == 0) {
+		if (!otp)
+			puts("Board : OTP board FREE\n");
+		else
+			display_stboard(otp);
+		return CMD_RET_SUCCESS;
+	}
+
+	if (otp) {
+		display_stboard(otp);
+		printf("ERROR: OTP board not FREE\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (strict_strtoul(argv[0], 16, &board) < 0 ||
+	    board == 0 || board > 0xFFFF) {
+		printf("argument %d invalid: %s\n", 1, argv[0]);
+		return CMD_RET_USAGE;
+	}
+
+	if (strict_strtoul(argv[1], 10, &variant) < 0 ||
+	    variant == 0 || variant > 15) {
+		printf("argument %d invalid: %s\n", 2, argv[1]);
+		return CMD_RET_USAGE;
+	}
+
+	revision = argv[2][0] - 'A' + 1;
+	if (strlen(argv[2]) > 1 || revision == 0 || revision > 15) {
+		printf("argument %d invalid: %s\n", 3, argv[2]);
+		return CMD_RET_USAGE;
+	}
+
+	if (strict_strtoul(argv[3], 10, &bom) < 0 ||
+	    bom == 0 || bom > 15) {
+		printf("argument %d invalid: %s\n", 4, argv[3]);
+		return CMD_RET_USAGE;
+	}
+
+	otp = (board << 16) | (variant << 12) | (revision << 8) | bom;
+	display_stboard(otp);
+	printf("=> OTP[%d] = %08X\n", BSEC_OTP_BOARD, otp);
+
+	if (!check_stboard((u16)board)) {
+		printf("Unknown board MB%04x\n", (u16)board);
+		return CMD_RET_FAILURE;
+	}
+	if (!confirmed) {
+		printf("Warning: Programming BOARD in OTP is irreversible!\n");
+		printf("Really perform this OTP programming? <y/N>\n");
+
+		if (!confirm_yesno()) {
+			puts("BOARD programming aborted\n");
+			return CMD_RET_FAILURE;
+		}
+	}
+
+	ret = misc_write(dev, STM32_BSEC_OTP(BSEC_OTP_BOARD),
+			 &otp, sizeof(otp));
+
+	if (ret) {
+		puts("BOARD programming error\n");
+		return CMD_RET_FAILURE;
+	}
+	puts("BOARD programming done\n");
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(stboard, 6, 0, do_stboard,
+	   "read/write board reference in OTP",
+	   "\n"
+	   "  Print current board information\n"
+	   "stboard [-y] <Board> <Variant> <Revision> <BOM>\n"
+	   "  Write board information\n"
+	   "  - Board: xxxx, example 1264 for MB1264\n"
+	   "  - Variant: 1 ... 15\n"
+	   "  - Revision: A...O\n"
+	   "  - BOM: 1...15\n");
diff --git a/board/st/stm32mp1/spl.c b/board/st/stm32mp1/spl.c
index a7844f244b..e19be0f770 100644
--- a/board/st/stm32mp1/spl.c
+++ b/board/st/stm32mp1/spl.c
@@ -9,7 +9,6 @@
 #include <dm.h>
 #include <ram.h>
 #include <asm/io.h>
-#include <post.h>
 #include <power/pmic.h>
 #include <power/stpmic1.h>
 #include <asm/arch/ddr.h>
diff --git a/board/st/stm32mp1/stm32mp1.c b/board/st/stm32mp1/stm32mp1.c
index 776929350f..fd3297aa68 100644
--- a/board/st/stm32mp1/stm32mp1.c
+++ b/board/st/stm32mp1/stm32mp1.c
@@ -76,7 +76,9 @@ int checkboard(void)
 	const char *fdt_compat;
 	int fdt_compat_len;
 
-	if (IS_ENABLED(CONFIG_STM32MP1_TRUSTED))
+	if (IS_ENABLED(CONFIG_STM32MP1_OPTEE))
+		mode = "op-tee";
+	else if (IS_ENABLED(CONFIG_STM32MP1_TRUSTED))
 		mode = "trusted";
 	else
 		mode = "basic";
@@ -515,6 +517,10 @@ int board_init(void)
 
 	board_key_check();
 
+#ifdef CONFIG_DM_REGULATOR
+	regulators_enable_boot_on(_DEBUG);
+#endif
+
 	sysconf_init();
 
 	if (IS_ENABLED(CONFIG_LED))
diff --git a/configs/stm32mp15_basic_defconfig b/configs/stm32mp15_basic_defconfig
index 4aa184fb5b..a5061fe8a4 100644
--- a/configs/stm32mp15_basic_defconfig
+++ b/configs/stm32mp15_basic_defconfig
@@ -43,6 +43,7 @@ CONFIG_CMD_MTDPARTS=y
 CONFIG_CMD_UBI=y
 # CONFIG_SPL_DOS_PARTITION is not set
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp157c-ev1"
+CONFIG_OF_SPL_REMOVE_PROPS="interrupts interrupt-names interrupts-extended interrupt-controller \\\#interrupt-cells interrupt-parent dmas dma-names assigned-clocks assigned-clock-rates assigned-clock-parents hwlocks"
 CONFIG_ENV_IS_NOWHERE=y
 CONFIG_ENV_IS_IN_EXT4=y
 CONFIG_ENV_IS_IN_SPI_FLASH=y
@@ -94,6 +95,8 @@ CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_STM32_VREFBUF=y
 CONFIG_DM_REGULATOR_STPMIC1=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
 CONFIG_STM32_SERIAL=y
 CONFIG_SPI=y
@@ -110,5 +113,3 @@ CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
 CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
-CONFIG_WDT=y
-CONFIG_WDT_STM32MP=y
diff --git a/configs/stm32mp15_optee_defconfig b/configs/stm32mp15_optee_defconfig
new file mode 100644
index 0000000000..e3c5108164
--- /dev/null
+++ b/configs/stm32mp15_optee_defconfig
@@ -0,0 +1,73 @@
+CONFIG_ARM=y
+CONFIG_ARCH_STM32MP=y
+CONFIG_SYS_MALLOC_F_LEN=0x3000
+CONFIG_TARGET_STM32MP1=y
+CONFIG_STM32MP1_OPTEE=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_FIT=y
+CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
+CONFIG_SYS_PROMPT="STM32MP> "
+# CONFIG_CMD_BOOTD is not set
+# CONFIG_CMD_ELF is not set
+# CONFIG_CMD_IMI is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_EXPORTENV is not set
+# CONFIG_CMD_IMPORTENV is not set
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_ADC=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_TIMER=y
+CONFIG_CMD_PMIC=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_DEFAULT_DEVICE_TREE="stm32mp157c-ev1"
+CONFIG_STM32_ADC=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
+CONFIG_FASTBOOT_BUF_SIZE=0x02000000
+CONFIG_FASTBOOT_USB_DEV=1
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=1
+CONFIG_DM_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_STM32=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_STM32F7=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_DM_MMC=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_STM32_SDMMC2=y
+CONFIG_PHY=y
+CONFIG_PHY_STM32_USBPHYC=y
+CONFIG_PINCONF=y
+CONFIG_PINCTRL_STMFX=y
+CONFIG_DM_PMIC=y
+CONFIG_PMIC_STPMIC1=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_REGULATOR_STM32_VREFBUF=y
+CONFIG_DM_REGULATOR_STPMIC1=y
+CONFIG_SERIAL_RX_BUFFER=y
+CONFIG_STM32_SERIAL=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0483
+CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
+CONFIG_USB_GADGET_DWC2_OTG=y
+
diff --git a/configs/stm32mp15_trusted_defconfig b/configs/stm32mp15_trusted_defconfig
index 5fe9477823..b329f6ff98 100644
--- a/configs/stm32mp15_trusted_defconfig
+++ b/configs/stm32mp15_trusted_defconfig
@@ -84,6 +84,8 @@ CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_STM32_VREFBUF=y
 CONFIG_DM_REGULATOR_STPMIC1=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
 CONFIG_STM32_SERIAL=y
 CONFIG_SPI=y
@@ -100,5 +102,3 @@ CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
 CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
-CONFIG_WDT=y
-CONFIG_WDT_STM32MP=y
diff --git a/doc/device-tree-bindings/pinctrl/st,stm32-pinctrl.txt b/doc/device-tree-bindings/pinctrl/st,stm32-pinctrl.txt
index c41ae91f7a..00169255e4 100644
--- a/doc/device-tree-bindings/pinctrl/st,stm32-pinctrl.txt
+++ b/doc/device-tree-bindings/pinctrl/st,stm32-pinctrl.txt
@@ -8,8 +8,13 @@ controllers onto these pads.
 Pin controller node:
 Required properies:
  - compatible: value should be one of the following:
-   (a) "st,stm32f429-pinctrl"
-   (b) "st,stm32f746-pinctrl"
+   "st,stm32f429-pinctrl"
+   "st,stm32f469-pinctrl"
+   "st,stm32f746-pinctrl"
+   "st,stm32f769-pinctrl"
+   "st,stm32h743-pinctrl"
+   "st,stm32mp157-pinctrl"
+   "st,stm32mp157-z-pinctrl"
  - #address-cells: The value of this property must be 1
  - #size-cells	: The value of this property must be 1
  - ranges	: defines mapping between pin controller node (parent) to
@@ -32,13 +37,30 @@ Required properties:
 
 Optional properties:
  - reset:	  : Reference to the reset controller
- - interrupt-parent: phandle of the interrupt parent to which the external
-   GPIO interrupts are forwarded to.
- - st,syscfg: Should be phandle/offset pair. The phandle to the syscon node
-   which includes IRQ mux selection register, and the offset of the IRQ mux
-   selection register.
+ - st,syscfg: Should be phandle/offset/mask.
+	-The phandle to the syscon node which includes IRQ mux selection register.
+	-The offset of the IRQ mux selection register
+	-The field mask of IRQ mux, needed if different of 0xf.
+ - gpio-ranges: Define a dedicated mapping between a pin-controller and
+   a gpio controller. Format is <&phandle a b c> with:
+	-(phandle): phandle of pin-controller.
+	-(a): gpio base offset in range.
+	-(b): pin base offset in range.
+	-(c): gpio count in range
+   This entry has to be used either if there are holes inside a bank:
+	GPIOB0/B1/B2/B14/B15 (see example 2)
+   or if banks are not contiguous:
+	GPIOA/B/C/E...
+   NOTE: If "gpio-ranges" is used for a gpio controller, all gpio-controller
+   have to use a "gpio-ranges" entry.
+   More details in Documentation/devicetree/bindings/gpio/gpio.txt.
+ - st,bank-ioport: should correspond to the EXTI IOport selection (EXTI line
+   used to select GPIOs as interrupts).
+ - hwlocks: reference to a phandle of a hardware spinlock provider node.
+ - st,package: Indicates the SOC package used.
+   More details in include/dt-bindings/pinctrl/stm32-pinfunc.h
 
-Example:
+Example 1:
 #include <dt-bindings/pinctrl/stm32f429-pinfunc.h>
 ...
 
@@ -60,6 +82,43 @@ Example:
 		pin-functions nodes follow...
 	};
 
+Example 2:
+#include <dt-bindings/pinctrl/stm32f429-pinfunc.h>
+...
+
+	pinctrl: pin-controller {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,stm32f429-pinctrl";
+		ranges = <0 0x40020000 0x3000>;
+		pins-are-numbered;
+
+		gpioa: gpio@40020000 {
+			gpio-controller;
+			#gpio-cells = <2>;
+			reg = <0x0 0x400>;
+			resets = <&reset_ahb1 0>;
+			st,bank-name = "GPIOA";
+			gpio-ranges = <&pinctrl 0 0 16>;
+		};
+
+		gpiob: gpio@40020400 {
+			gpio-controller;
+			#gpio-cells = <2>;
+			reg = <0x0 0x400>;
+			resets = <&reset_ahb1 0>;
+			st,bank-name = "GPIOB";
+			ngpios = 4;
+			gpio-ranges = <&pinctrl 0 16 3>,
+				      <&pinctrl 14 30 2>;
+		};
+
+
+		...
+		pin-functions nodes follow...
+	};
+
+
 Contents of function subnode node:
 ----------------------------------
 Subnode format
@@ -83,14 +142,31 @@ Required properties:
     - port: The gpio port index (PA = 0, PB = 1, ..., PK = 11)
     - line: The line offset within the port (PA0 = 0, PA1 = 1, ..., PA15 = 15)
     - function: The function number, can be:
-      * 0 : GPIO IN
+      * 0 : GPIO
       * 1 : Alternate Function 0
       * 2 : Alternate Function 1
       * 3 : Alternate Function 2
       * ...
       * 16 : Alternate Function 15
       * 17 : Analog
-      * 18 : GPIO OUT
+
+  To simplify the usage, macro is available to generate "pinmux" field.
+  This macro is available here:
+    - include/dt-bindings/pinctrl/stm32-pinfunc.h
+
+  Some examples of using macro:
+    /* GPIO A9 set as alernate function 2 */
+    ... {
+		pinmux = <STM32_PINMUX('A', 9, AF2)>;
+    };
+    /* GPIO A9 set as GPIO  */
+    ... {
+		pinmux = <STM32_PINMUX('A', 9, GPIO)>;
+    };
+    /* GPIO A9 set as analog */
+    ... {
+		pinmux = <STM32_PINMUX('A', 9, ANALOG)>;
+    };
 
 Optional properties:
 - GENERIC_PINCONFIG: is the generic pinconfig options to use.
@@ -114,13 +190,13 @@ pin-controller {
 ...
 	usart1_pins_a: usart1@0 {
 		pins1 {
-			pinmux = <STM32F429_PA9_FUNC_USART1_TX>;
+			pinmux = <STM32_PINMUX('A', 9, AF7)>;
 			bias-disable;
 			drive-push-pull;
 			slew-rate = <0>;
 		};
 		pins2 {
-			pinmux = <STM32F429_PA10_FUNC_USART1_RX>;
+			pinmux = <STM32_PINMUX('A', 10, AF7)>;
 			bias-disable;
 		};
 	};
@@ -129,5 +205,4 @@ pin-controller {
 &usart1 {
 	pinctrl-0 = <&usart1_pins_a>;
 	pinctrl-names = "default";
-	status = "okay";
 };
diff --git a/drivers/clk/clk_stm32mp1.c b/drivers/clk/clk_stm32mp1.c
index f295e4864b..941e73cf8f 100644
--- a/drivers/clk/clk_stm32mp1.c
+++ b/drivers/clk/clk_stm32mp1.c
@@ -300,6 +300,7 @@ enum stm32mp1_parent_sel {
 	_DSI_SEL,
 	_ADC12_SEL,
 	_SPI1_SEL,
+	_RTC_SEL,
 	_PARENT_SEL_NB,
 	_UNKNOWN_SEL = 0xff,
 };
@@ -534,6 +535,7 @@ static const struct stm32mp1_clk_gate stm32mp1_clk_gate[] = {
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 16, USBPHY_K, _USBPHY_SEL),
 
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 2, I2C4_K, _I2C46_SEL),
+	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 8, RTCAPB, _PCLK5),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB5ENSETR, 20, STGEN_K, _STGEN_SEL),
 
 	STM32MP1_CLK_SET_CLR_F(RCC_MP_AHB2ENSETR, 5, ADC12, _HCLK2),
@@ -569,6 +571,8 @@ static const struct stm32mp1_clk_gate stm32mp1_clk_gate[] = {
 	STM32MP1_CLK_SET_CLR(RCC_MP_AHB6ENSETR, 24, USBH, _UNKNOWN_SEL),
 
 	STM32MP1_CLK(RCC_DBGCFGR, 8, CK_DBG, _UNKNOWN_SEL),
+
+	STM32MP1_CLK(RCC_BDCR, 20, RTC, _RTC_SEL),
 };
 
 static const u8 i2c12_parents[] = {_PCLK1, _PLL4_R, _HSI_KER, _CSI_KER};
@@ -594,6 +598,7 @@ static const u8 dsi_parents[] = {_DSI_PHY, _PLL4_P};
 static const u8 adc_parents[] = {_PLL4_R, _CK_PER, _PLL3_Q};
 static const u8 spi_parents[] = {_PLL4_P, _PLL3_Q, _I2S_CKIN, _CK_PER,
 				 _PLL3_R};
+static const u8 rtc_parents[] = {_UNKNOWN_ID, _LSE, _LSI, _HSE};
 
 static const struct stm32mp1_clk_sel stm32mp1_clk_sel[_PARENT_SEL_NB] = {
 	STM32MP1_CLK_PARENT(_I2C12_SEL, RCC_I2C12CKSELR, 0, 0x7, i2c12_parents),
@@ -619,6 +624,9 @@ static const struct stm32mp1_clk_sel stm32mp1_clk_sel[_PARENT_SEL_NB] = {
 	STM32MP1_CLK_PARENT(_DSI_SEL, RCC_DSICKSELR, 0, 0x1, dsi_parents),
 	STM32MP1_CLK_PARENT(_ADC12_SEL, RCC_ADCCKSELR, 0, 0x1, adc_parents),
 	STM32MP1_CLK_PARENT(_SPI1_SEL, RCC_SPI2S1CKSELR, 0, 0x7, spi_parents),
+	STM32MP1_CLK_PARENT(_RTC_SEL, RCC_BDCR, RCC_BDCR_RTCSRC_SHIFT,
+			    (RCC_BDCR_RTCSRC_MASK >> RCC_BDCR_RTCSRC_SHIFT),
+			    rtc_parents),
 };
 
 #ifdef STM32MP1_CLOCK_TREE_INIT
@@ -734,6 +742,7 @@ char * const stm32mp1_clk_parent_sel_name[_PARENT_SEL_NB] = {
 	[_DSI_SEL] = "DSI",
 	[_ADC12_SEL] = "ADC12",
 	[_SPI1_SEL] = "SPI1",
+	[_RTC_SEL] = "RTC",
 };
 
 static const struct stm32mp1_clk_data stm32mp1_data = {
@@ -1542,8 +1551,7 @@ static void stgen_config(struct stm32mp1_clk_priv *priv)
 	u32 stgenc, cntfid0;
 	ulong rate;
 
-	stgenc = (u32)syscon_get_first_range(STM32MP_SYSCON_STGEN);
-
+	stgenc = STM32_STGEN_BASE;
 	cntfid0 = readl(stgenc + STGENC_CNTFID0);
 	p = stm32mp1_clk_get_parent(priv, STGEN_K);
 	rate = stm32mp1_clk_get(priv, p);
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index fd0009b2e2..a383e632ad 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -110,4 +110,10 @@ config RTC_M41T62
 	  Enable driver for ST's M41T62 compatible RTC devices (like RV-4162).
 	  It is a serial (I2C) real-time clock (RTC) with alarm.
 
+config RTC_STM32
+	bool "Enable STM32 RTC driver"
+	depends on DM_RTC
+	help
+	  Enable STM32 RTC driver. This driver supports the rtc that is present
+	  on some STM32 SoCs.
 endmenu
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 1724602f1c..90e79fb30d 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -50,5 +50,6 @@ obj-$(CONFIG_RTC_RX8025) += rx8025.o
 obj-$(CONFIG_RTC_RX8010SJ) += rx8010sj.o
 obj-$(CONFIG_RTC_S3C24X0) += s3c24x0_rtc.o
 obj-$(CONFIG_RTC_S35392A) += s35392a.o
+obj-$(CONFIG_RTC_STM32) += stm32_rtc.o
 obj-$(CONFIG_SANDBOX) += sandbox_rtc.o
 obj-$(CONFIG_RTC_X1205) += x1205.o
diff --git a/drivers/rtc/stm32_rtc.c b/drivers/rtc/stm32_rtc.c
new file mode 100644
index 0000000000..5d0ffdbc9f
--- /dev/null
+++ b/drivers/rtc/stm32_rtc.c
@@ -0,0 +1,321 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2019, STMicroelectronics - All Rights Reserved
+ */
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <rtc.h>
+#include <asm/io.h>
+#include <linux/iopoll.h>
+
+#define STM32_RTC_TR		0x00
+#define STM32_RTC_DR		0x04
+#define STM32_RTC_ISR		0x0C
+#define STM32_RTC_PRER		0x10
+#define STM32_RTC_CR		0x18
+#define STM32_RTC_WPR		0x24
+
+/* STM32_RTC_TR bit fields  */
+#define STM32_RTC_SEC_SHIFT	0
+#define STM32_RTC_SEC		GENMASK(6, 0)
+#define STM32_RTC_MIN_SHIFT	8
+#define STM32_RTC_MIN		GENMASK(14, 8)
+#define STM32_RTC_HOUR_SHIFT	16
+#define STM32_RTC_HOUR		GENMASK(21, 16)
+
+/* STM32_RTC_DR bit fields */
+#define STM32_RTC_DATE_SHIFT	0
+#define STM32_RTC_DATE		GENMASK(5, 0)
+#define STM32_RTC_MONTH_SHIFT	8
+#define STM32_RTC_MONTH		GENMASK(12, 8)
+#define STM32_RTC_WDAY_SHIFT	13
+#define STM32_RTC_WDAY		GENMASK(15, 13)
+#define STM32_RTC_YEAR_SHIFT	16
+#define STM32_RTC_YEAR		GENMASK(23, 16)
+
+/* STM32_RTC_CR bit fields */
+#define STM32_RTC_CR_FMT	BIT(6)
+
+/* STM32_RTC_ISR/STM32_RTC_ICSR bit fields */
+#define STM32_RTC_ISR_INITS	BIT(4)
+#define STM32_RTC_ISR_RSF	BIT(5)
+#define STM32_RTC_ISR_INITF	BIT(6)
+#define STM32_RTC_ISR_INIT	BIT(7)
+
+/* STM32_RTC_PRER bit fields */
+#define STM32_RTC_PRER_PRED_S_SHIFT	0
+#define STM32_RTC_PRER_PRED_S		GENMASK(14, 0)
+#define STM32_RTC_PRER_PRED_A_SHIFT	16
+#define STM32_RTC_PRER_PRED_A		GENMASK(22, 16)
+
+/* STM32_RTC_WPR key constants */
+#define RTC_WPR_1ST_KEY		0xCA
+#define RTC_WPR_2ND_KEY		0x53
+#define RTC_WPR_WRONG_KEY	0xFF
+
+struct stm32_rtc_priv {
+	fdt_addr_t base;
+};
+
+static int stm32_rtc_get(struct udevice *dev, struct rtc_time *tm)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	u32 tr, dr;
+
+	tr = readl(priv->base + STM32_RTC_TR);
+	dr = readl(priv->base + STM32_RTC_DR);
+
+	tm->tm_sec = bcd2bin((tr & STM32_RTC_SEC) >> STM32_RTC_SEC_SHIFT);
+	tm->tm_min = bcd2bin((tr & STM32_RTC_MIN) >> STM32_RTC_MIN_SHIFT);
+	tm->tm_hour = bcd2bin((tr & STM32_RTC_HOUR) >> STM32_RTC_HOUR_SHIFT);
+
+	tm->tm_mday = bcd2bin((dr & STM32_RTC_DATE) >> STM32_RTC_DATE_SHIFT);
+	tm->tm_mon = bcd2bin((dr & STM32_RTC_MONTH) >> STM32_RTC_MONTH_SHIFT);
+	tm->tm_year = bcd2bin((dr & STM32_RTC_YEAR) >> STM32_RTC_YEAR_SHIFT);
+	tm->tm_wday = bcd2bin((dr & STM32_RTC_WDAY) >> STM32_RTC_WDAY_SHIFT);
+	tm->tm_yday = 0;
+	tm->tm_isdst = 0;
+
+	dev_dbg(dev, "Get DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_wday,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	return 0;
+}
+
+static void stm32_rtc_unlock(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+
+	writel(RTC_WPR_1ST_KEY, priv->base + STM32_RTC_WPR);
+	writel(RTC_WPR_2ND_KEY, priv->base + STM32_RTC_WPR);
+}
+
+static void stm32_rtc_lock(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+
+	writel(RTC_WPR_WRONG_KEY, priv->base + STM32_RTC_WPR);
+}
+
+static int stm32_rtc_enter_init_mode(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	u32 isr = readl(priv->base + STM32_RTC_ISR);
+
+	if (!(isr & STM32_RTC_ISR_INITF)) {
+		isr |= STM32_RTC_ISR_INIT;
+		writel(isr, priv->base + STM32_RTC_ISR);
+
+		return readl_poll_timeout(priv->base + STM32_RTC_ISR,
+					  isr,
+					  (isr & STM32_RTC_ISR_INITF),
+					  100000);
+	}
+
+	return 0;
+}
+
+static int stm32_rtc_wait_sync(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	u32 isr = readl(priv->base + STM32_RTC_ISR);
+
+	isr &= ~STM32_RTC_ISR_RSF;
+	writel(isr, priv->base + STM32_RTC_ISR);
+
+	/*
+	 * Wait for RSF to be set to ensure the calendar registers are
+	 * synchronised, it takes around 2 rtc_ck clock cycles
+	 */
+	return readl_poll_timeout(priv->base + STM32_RTC_ISR,
+				  isr, (isr & STM32_RTC_ISR_RSF),
+				  100000);
+}
+
+static void stm32_rtc_exit_init_mode(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	u32 isr = readl(priv->base + STM32_RTC_ISR);
+
+	isr &= ~STM32_RTC_ISR_INIT;
+	writel(isr, priv->base + STM32_RTC_ISR);
+}
+
+static int stm32_rtc_set_time(struct udevice *dev, u32 time, u32 date)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	stm32_rtc_unlock(dev);
+
+	ret = stm32_rtc_enter_init_mode(dev);
+	if (ret)
+		goto lock;
+
+	writel(time, priv->base + STM32_RTC_TR);
+	writel(date, priv->base + STM32_RTC_DR);
+
+	stm32_rtc_exit_init_mode(dev);
+
+	ret = stm32_rtc_wait_sync(dev);
+
+lock:
+	stm32_rtc_lock(dev);
+	return ret;
+}
+
+static int stm32_rtc_set(struct udevice *dev, const struct rtc_time *tm)
+{
+	u32 t, d;
+
+	dev_dbg(dev, "Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_wday,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	/* Time in BCD format */
+	t = (bin2bcd(tm->tm_sec) << STM32_RTC_SEC_SHIFT) & STM32_RTC_SEC;
+	t |= (bin2bcd(tm->tm_min) << STM32_RTC_MIN_SHIFT) & STM32_RTC_MIN;
+	t |= (bin2bcd(tm->tm_hour) << STM32_RTC_HOUR_SHIFT) & STM32_RTC_HOUR;
+
+	/* Date in BCD format */
+	d = (bin2bcd(tm->tm_mday) << STM32_RTC_DATE_SHIFT) & STM32_RTC_DATE;
+	d |= (bin2bcd(tm->tm_mon) << STM32_RTC_MONTH_SHIFT) & STM32_RTC_MONTH;
+	d |= (bin2bcd(tm->tm_year) << STM32_RTC_YEAR_SHIFT) & STM32_RTC_YEAR;
+	d |= (bin2bcd(tm->tm_wday) << STM32_RTC_WDAY_SHIFT) & STM32_RTC_WDAY;
+
+	return stm32_rtc_set_time(dev, t, d);
+}
+
+static int stm32_rtc_reset(struct udevice *dev)
+{
+	dev_dbg(dev, "Reset DATE\n");
+
+	return stm32_rtc_set_time(dev, 0, 0);
+}
+
+static int stm32_rtc_init(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	unsigned int prer, pred_a, pred_s, pred_a_max, pred_s_max, cr;
+	unsigned int rate;
+	struct clk clk;
+	int ret;
+	u32 isr = readl(priv->base + STM32_RTC_ISR);
+
+	if (isr & STM32_RTC_ISR_INITS)
+		return  0;
+
+	ret = clk_get_by_index(dev, 1, &clk);
+	if (ret)
+		return ret;
+
+	ret = clk_enable(&clk);
+	if (ret) {
+		clk_free(&clk);
+		return ret;
+	}
+
+	rate = clk_get_rate(&clk);
+
+	/* Find prediv_a and prediv_s to obtain the 1Hz calendar clock */
+	pred_a_max = STM32_RTC_PRER_PRED_A >> STM32_RTC_PRER_PRED_A_SHIFT;
+	pred_s_max = STM32_RTC_PRER_PRED_S >> STM32_RTC_PRER_PRED_S_SHIFT;
+
+	for (pred_a = pred_a_max; pred_a + 1 > 0; pred_a--) {
+		pred_s = (rate / (pred_a + 1)) - 1;
+
+		if (((pred_s + 1) * (pred_a + 1)) == rate)
+			break;
+	}
+
+	/*
+	 * Can't find a 1Hz, so give priority to RTC power consumption
+	 * by choosing the higher possible value for prediv_a
+	 */
+	if (pred_s > pred_s_max || pred_a > pred_a_max) {
+		pred_a = pred_a_max;
+		pred_s = (rate / (pred_a + 1)) - 1;
+	}
+
+	stm32_rtc_unlock(dev);
+
+	ret = stm32_rtc_enter_init_mode(dev);
+	if (ret) {
+		dev_err(dev,
+			"Can't enter in init mode. Prescaler config failed.\n");
+		goto unlock;
+	}
+
+	prer = (pred_s << STM32_RTC_PRER_PRED_S_SHIFT) & STM32_RTC_PRER_PRED_S;
+	prer |= (pred_a << STM32_RTC_PRER_PRED_A_SHIFT) & STM32_RTC_PRER_PRED_A;
+	writel(prer, priv->base + STM32_RTC_PRER);
+
+	/* Force 24h time format */
+	cr = readl(priv->base + STM32_RTC_CR);
+	cr &= ~STM32_RTC_CR_FMT;
+	writel(cr, priv->base + STM32_RTC_CR);
+
+	stm32_rtc_exit_init_mode(dev);
+
+	ret = stm32_rtc_wait_sync(dev);
+
+unlock:
+	stm32_rtc_lock(dev);
+
+	clk_disable(&clk);
+	clk_free(&clk);
+
+	return ret;
+}
+
+static int stm32_rtc_probe(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	struct clk clk;
+	int ret;
+
+	priv->base = dev_read_addr(dev);
+	if (priv->base == FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	ret = clk_get_by_index(dev, 0, &clk);
+	if (ret)
+		return ret;
+
+	ret = clk_enable(&clk);
+	if (ret) {
+		clk_free(&clk);
+		return ret;
+	}
+
+	ret = stm32_rtc_init(dev);
+
+	if (ret) {
+		clk_disable(&clk);
+		clk_free(&clk);
+	}
+
+	return ret;
+}
+
+static const struct rtc_ops stm32_rtc_ops = {
+	.get = stm32_rtc_get,
+	.set = stm32_rtc_set,
+	.reset = stm32_rtc_reset,
+};
+
+static const struct udevice_id stm32_rtc_ids[] = {
+	{ .compatible = "st,stm32mp1-rtc" },
+	{ }
+};
+
+U_BOOT_DRIVER(rtc_stm32) = {
+	.name	= "rtc-stm32",
+	.id	= UCLASS_RTC,
+	.probe	= stm32_rtc_probe,
+	.of_match = stm32_rtc_ids,
+	.ops	= &stm32_rtc_ops,
+	.priv_auto_alloc_size = sizeof(struct stm32_rtc_priv),
+};
diff --git a/include/configs/stm32mp1.h b/include/configs/stm32mp1.h
index 1d385e0985..e2cc3c5160 100644
--- a/include/configs/stm32mp1.h
+++ b/include/configs/stm32mp1.h
@@ -143,9 +143,13 @@
 	"ramdisk_addr_r=0xc4400000\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
+	"env_default=1\0"				\
+	"env_check=if test $env_default -eq 1;"\
+		" then env set env_default 0;env save;fi\0" \
 	STM32MP_BOOTCMD \
 	STM32MP_MTDPARTS \
-	BOOTENV
+	BOOTENV \
+	"boot_net_usb_start=true\0"
 
 #endif /* ifndef CONFIG_SPL_BUILD */
 #endif /* ifdef CONFIG_DISTRO_DEFAULTS*/
diff --git a/include/dt-bindings/pinctrl/stm32-pinfunc.h b/include/dt-bindings/pinctrl/stm32-pinfunc.h
index b5a2174a63..e6fb8ada3f 100644
--- a/include/dt-bindings/pinctrl/stm32-pinfunc.h
+++ b/include/dt-bindings/pinctrl/stm32-pinfunc.h
@@ -32,5 +32,11 @@
 
 #define STM32_PINMUX(port, line, mode) (((PIN_NO(port, line)) << 8) | (mode))
 
+/*  package information */
+#define STM32MP_PKG_AA	0x1
+#define STM32MP_PKG_AB	0x2
+#define STM32MP_PKG_AC	0x4
+#define STM32MP_PKG_AD	0x8
+
 #endif /* _DT_BINDINGS_STM32_PINFUNC_H */
 
-- 
2.17.1

